<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AbstractPlotting Reference · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Makie.jl logo"/></a><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="basic-tutorials.html">Tutorial</a></li><li><a class="toctext" href="statsmakie.html">StatsMakie Tutorial</a></li><li><a class="toctext" href="help_functions.html">Help functions</a></li><li><a class="toctext" href="functions-overview.html">Plotting functions overview</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="interaction.html">Interaction</a></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="plot-attributes.html">Plot attributes</a></li><li><a class="toctext" href="colors.html">Colors</a></li><li><a class="toctext" href="theming.html">Config file</a></li><li><a class="toctext" href="cameras.html">Cameras</a></li><li><a class="toctext" href="backends.html">Backends</a></li><li><a class="toctext" href="axis.html">Axis</a></li><li><a class="toctext" href="recipes.html">Plot Recipes</a></li><li><a class="toctext" href="output.html">Output</a></li><li><a class="toctext" href="troubleshooting.html">Troubleshooting</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="why-makie.html">Why <code>Makie</code>?</a></li><li><a class="toctext" href="devdocs.html">Devdocs</a></li><li class="current"><a class="toctext" href="abstractplotting_api.html">AbstractPlotting Reference</a><ul class="internal"><li><a class="toctext" href="#What&#39;s-exported-1">What&#39;s exported</a></li><li><a class="toctext" href="#What-isn&#39;t-1">What isn&#39;t</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li><a href="abstractplotting_api.html">AbstractPlotting Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/MakieGallery.jl/blob/master/docs/src/abstractplotting_api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>AbstractPlotting Reference</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="What&#39;s-exported-1" href="#What&#39;s-exported-1">What&#39;s exported</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Absolute" href="#AbstractPlotting.Absolute"><code>AbstractPlotting.Absolute</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Absolute</code></pre><p>Force transformation to be absolute, not relative to the current state. This is the default setting.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L150-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Accum" href="#AbstractPlotting.Accum"><code>AbstractPlotting.Accum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Accum</code></pre><p>Force transformation to be relative to the current state, not absolute.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L144-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Billboard" href="#AbstractPlotting.Billboard"><code>AbstractPlotting.Billboard</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L446-L449">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.FRect3D" href="#AbstractPlotting.FRect3D"><code>AbstractPlotting.FRect3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An float valued, three dimensional rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect2D" href="#AbstractPlotting.IRect2D"><code>AbstractPlotting.IRect2D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An integer valued, two dimensional rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect3D" href="#AbstractPlotting.IRect3D"><code>AbstractPlotting.IRect3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An integer valued, three dimensional rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotList" href="#AbstractPlotting.PlotList"><code>AbstractPlotting.PlotList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Plotlist(plots...)</code></p><p>Experimental feature. Create an object that can encode multiple series.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/multiple.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.PlotSpec" href="#AbstractPlotting.PlotSpec"><code>AbstractPlotting.PlotSpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L468-L473">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Rect3D" href="#AbstractPlotting.Rect3D"><code>AbstractPlotting.Rect3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A generic, three dimensional rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Reverse" href="#AbstractPlotting.Reverse"><code>AbstractPlotting.Reverse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reverses the attribute T upon conversion</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L622-L624">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.VideoStream-Tuple{Scene}" href="#AbstractPlotting.VideoStream-Tuple{Scene}"><code>AbstractPlotting.VideoStream</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VideoStream(scene::Scene, framerate = 24)</code></pre><p>Returns a stream and a buffer that you can use, which don&#39;t allocate for new frames. Use <a href="abstractplotting_api.html#AbstractPlotting.recordframe!-Tuple{VideoStream}"><code>recordframe!(stream)</code></a> to add new video frames to the stream, and <a href="abstractplotting_api.html#FileIO.save-Tuple{String,VideoStream}"><code>save(path, stream)</code></a> to save the video.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L276-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.FRect-NTuple{4,Any}" href="#AbstractPlotting.FRect-NTuple{4,Any}"><code>AbstractPlotting.FRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FRect(x, y, w, h)</code></pre><p>Creates a two dimensional rectangle, at origin (x, y) and with width w and height h.  Formally defined as the Cartesian product of the intervals (x, y) and (w, h).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L105-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect-NTuple{4,Any}" href="#AbstractPlotting.IRect-NTuple{4,Any}"><code>AbstractPlotting.IRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IRect(x, y, w, h)</code></pre><p>Creates a two dimensional rectangle of integer dimensions, at origin (x, y) and with width w and height h</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L49-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect-Tuple{Any,Any,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.IRect-Tuple{Any,Any,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.IRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IRect(x, y, wh::VecTypes)</code></pre><p>Creates a two dimensional rectangle of integer dimensions, with origin at (x, y), and with width and height as the respective components of vector wh</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L69-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect-Tuple{NamedTuple{(:x, :y),T} where T&lt;:Tuple,NamedTuple{(:width, :height),T} where T&lt;:Tuple}" href="#AbstractPlotting.IRect-Tuple{NamedTuple{(:x, :y),T} where T&lt;:Tuple,NamedTuple{(:width, :height),T} where T&lt;:Tuple}"><code>AbstractPlotting.IRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IRect(xy::NamedTuple{(:x, :y)}, wh::NamedTuple{(:width, :height)})</code></pre><p>This takes two named tuples and constructs an integer valued rectangle with them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L89-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N,Any,Any}" href="#AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N,Any,Any}"><code>AbstractPlotting.IRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IRect(xy::VecTypes, w, h)</code></pre><p>Creates a two dimensional rectangle of integer dimensions, with origin at vector xy, and with width w and height h</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L59-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.IRect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IRect(xy::VecTypes, wh::VecTypes)</code></pre><p>Creates a two dimensional rectangle of integer dimensions, with origin at vector xy, and with width and height as the respective components of vector wh</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L79-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple" href="#AbstractPlotting.annotations!-Tuple"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`annotations(strings::Vector{String}, positions::Vector{Point})`</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.annotations-Tuple" href="#AbstractPlotting.annotations-Tuple"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`annotations(strings::Vector{String}, positions::Vector{Point})`</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple" href="#AbstractPlotting.arc!-Tuple"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f0(0), 1, 0.0, π)</code> <code>arc(Point2f0(1, 2), 0.3. π, -π)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arc-Tuple" href="#AbstractPlotting.arc-Tuple"><code>AbstractPlotting.arc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f0(0), 1, 0.0, π)</code> <code>arc(Point2f0(1, 2), 0.3. π, -π)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple" href="#AbstractPlotting.arrows!-Tuple"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`arrows(points, directions; kwargs...)`
`arrows(x, y, u, v)`
`arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)`
`arrows(x, y, z, u, v, w)`</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each &#39;row&#39; is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.arrows-Tuple" href="#AbstractPlotting.arrows-Tuple"><code>AbstractPlotting.arrows</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`arrows(points, directions; kwargs...)`
`arrows(x, y, u, v)`
`arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)`
`arrows(x, y, z, u, v, w)`</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each &#39;row&#39; is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band!-Tuple" href="#AbstractPlotting.band!-Tuple"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">band(x, ylower, yupper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.band-Tuple" href="#AbstractPlotting.band-Tuple"><code>AbstractPlotting.band</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">band(x, ylower, yupper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple" href="#AbstractPlotting.barplot!-Tuple"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.barplot-Tuple" href="#AbstractPlotting.barplot-Tuple"><code>AbstractPlotting.barplot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.broadcast_foreach</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Like broadcast but for foreach. Doesn&#39;t care about shape and treats Tuples &amp;&amp; StaticVectors as scalars.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L186-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button!-Tuple" href="#AbstractPlotting.button!-Tuple"><code>AbstractPlotting.button!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Button</code></pre><p>TODO add function signatures TODO add description</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.button-Tuple" href="#AbstractPlotting.button-Tuple"><code>AbstractPlotting.button</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Button</code></pre><p>TODO add function signatures TODO add description</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam2d!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.cam2d!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.cam2d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cam2d!(scene::SceneLike, kwargs...)</code></pre><p>Creates a 2D camera for the given Scene.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera2d.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam2d-Tuple{Scene}" href="#AbstractPlotting.cam2d-Tuple{Scene}"><code>AbstractPlotting.cam2d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Creates a subscene with a pixel camera</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L138-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam3d_cad!-Tuple{Any}" href="#AbstractPlotting.cam3d_cad!-Tuple{Any}"><code>AbstractPlotting.cam3d_cad!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cam3d_cad!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code> which rotates around the <em>viewer</em>&#39;s &quot;up&quot; axis - similarly to how it&#39;s done in CAD software cameras.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera3d.jl#L19-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.campixel!-Tuple{Any}" href="#AbstractPlotting.campixel!-Tuple{Any}"><code>AbstractPlotting.campixel!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">campixel!(scene)</code></pre><p>Creates a pixel-level camera for the <code>Scene</code>.  No controls!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera2d.jl#L276-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend!-Tuple" href="#AbstractPlotting.colorlegend!-Tuple"><code>AbstractPlotting.colorlegend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">colorlegend(scene, colormap, range)</code></pre><p>creates a legend from a colormap</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorlegend-Tuple" href="#AbstractPlotting.colorlegend-Tuple"><code>AbstractPlotting.colorlegend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">colorlegend(scene, colormap, range)</code></pre><p>creates a legend from a colormap</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple" href="#AbstractPlotting.contour!-Tuple"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">contour(x, y, z)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour-Tuple" href="#AbstractPlotting.contour-Tuple"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">contour(x, y, z)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple" href="#AbstractPlotting.contour3d!-Tuple"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.contour3d-Tuple" href="#AbstractPlotting.contour3d-Tuple"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L72-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L79-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y)::(Vector)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and turns it into a vector of 2D points of the values from <code>x</code> and <code>y</code>.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L155-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L146-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.GeometryPrimitive}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.GeometryPrimitive}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L88-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.HyperRectangle{2,T} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.HyperRectangle{2,T} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>HyperRectangle</code> <code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L188-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L230-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals&#39;s <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L168-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>Takes 3 <code>AbstractMatrix</code> <code>x</code>, <code>y</code>, and <code>z</code>, converts them to <code>Float32</code> and outputs them in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L209-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L290-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray,AbstractArray}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray,AbstractArray}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref">to_vertices</a> and <a href="@ref">to_triangles</a> for more informations about accepted types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L418-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryTypes.Face{N, &lt;: Integer}.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L356-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L312-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Mesh{...}),AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L324-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Text{...}),AbstractString}" href="#AbstractPlotting.convert_arguments-Tuple{Type{#s155} where #s155&lt;:(Text{...}),AbstractString}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(x)::(String)</code></pre><p>Takes an input <code>AbstractString</code> <code>x</code> and converts it to a string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L180-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{#s155} where #s155&lt;:(LineSegments{...}),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N" href="#AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{#s155} where #s155&lt;:(LineSegments{...}),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L137-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1" href="#AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y&#39;)</code>. <code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L243-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code> <code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L278-L284">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L262-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A Symbol/String naming the gradient. For more on what names are available please see: <code>available_gradients()</code>. For now, we support gradients from <code>PlotUtils</code> natively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L650-L653">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:colormap}}" href="#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:colormap}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_colormap(b, x)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="abstractplotting_api.html#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L634-L638">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`AbstractVector{&lt;:AbstractFloat}` for denoting sequences of fill/nofill. e.g.</code></pre><p>[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L485-L489">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_volume_algorithm(b, x)</code></pre><p>Enum values: <code>IsoValue</code> <code>Absorption</code> <code>MaximumIntensityProjection</code> <code>AbsorptionRGBA</code> <code>IndexedAbsorptionRGBA</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L670-L674">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}" href="#AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L560-L565">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Symbol,AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{Symbol,AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L492-L494">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}" href="#AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Text align, e.g.:</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L526-L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L687-L689">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">font conversion</code></pre><p>a string naming a font, e.g. helvetica</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L533-L537">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{Tuple, Pair},AbstractPlotting.Key{:colormap}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{Tuple, Pair},AbstractPlotting.Key{:colormap}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Tuple(A, B) or Pair{A, B} with any object that <a href="abstractplotting_api.html#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L641-L643">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fill_between!-Tuple{Any,Any,Any}" href="#AbstractPlotting.fill_between!-Tuple{Any,Any,Any}"><code>AbstractPlotting.fill_between!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/basic_recipes.jl#L606-L610">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.force_update!-Tuple{}" href="#AbstractPlotting.force_update!-Tuple{}"><code>AbstractPlotting.force_update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Forces the scene to be re-rendered</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L255-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.hbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}" href="#AbstractPlotting.hbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}"><code>AbstractPlotting.hbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hbox(scenes...; parent = Scene(clear = false), kwargs...)</code></pre><p>Lay the given Scenes out on the horizonral axis.  For example, two Scenes <code>vbox</code>ed will be placed side-by-side.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L185-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple" href="#AbstractPlotting.heatmap!-Tuple"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`heatmap(x, y, values)` or `heatmap(values)`</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.heatmap-Tuple" href="#AbstractPlotting.heatmap-Tuple"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`heatmap(x, y, values)` or `heatmap(values)`</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help-Tuple{Any}" href="#AbstractPlotting.help-Tuple{Any}"><code>AbstractPlotting.help</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>AbstractPlotting.jl</code>.</p><p>For help on a specific function&#39;s arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function&#39;s attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L4-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_arguments-Tuple{Any}" href="#AbstractPlotting.help_arguments-Tuple{Any}"><code>AbstractPlotting.help_arguments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L54-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.help_attributes-Tuple{Any}" href="#AbstractPlotting.help_attributes-Tuple{Any}"><code>AbstractPlotting.help_attributes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-example">&gt;help_attributes(scatter)
	alpha
	color
	colormap
	colorrange
	distancefield
	glowcolor
	glowwidth
	linewidth
	marker
	marker_offset
	markersize
	overdraw
	rotations
	strokecolor
	strokewidth
	transform_marker
	transparency
	uv_offset_width
	visible</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L75-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.hovered_scene-Tuple{}" href="#AbstractPlotting.hovered_scene-Tuple{}"><code>AbstractPlotting.hovered_scene</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hovered_scene()</code></pre><p>Return the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L116-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image!-Tuple" href="#AbstractPlotting.image!-Tuple"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`image(x, y, image)` / `image(image)`</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.image-Tuple" href="#AbstractPlotting.image-Tuple"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`image(x, y, image)` / `image(image)`</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Tuple, Array{T,1} where T}}" href="#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Tuple, Array{T,1} where T}}"><code>AbstractPlotting.ispressed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>returns true if <code>button</code> is pressed in scene[:mousebuttons or :keyboardbuttons] You can use nothing, to indicate it should always return true</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/events.jl#L74-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend!-Tuple" href="#AbstractPlotting.legend!-Tuple"><code>AbstractPlotting.legend!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`legend(plots, labels; kwargs...)`</code></pre><p>Plots a legend for the given plots with the given labels. <code>plots</code> may be a single Plot or a list of Plots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.legend-Tuple" href="#AbstractPlotting.legend-Tuple"><code>AbstractPlotting.legend</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`legend(plots, labels; kwargs...)`</code></pre><p>Plots a legend for the given plots with the given labels. <code>plots</code> may be a single Plot or a list of Plots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple" href="#AbstractPlotting.lines!-Tuple"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`lines(x, y, z)` / `lines(x, y)` / or `lines(positions)`</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lines-Tuple" href="#AbstractPlotting.lines-Tuple"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`lines(x, y, z)` / `lines(x, y)` / or `lines(positions)`</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple" href="#AbstractPlotting.linesegments!-Tuple"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`linesegments(x, y, z)` / `linesegments(x, y)` / `linesegments(positions)`</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong>: The same as for <a href="functions-overview.html#AbstractPlotting.lines"><code>lines</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.linesegments-Tuple" href="#AbstractPlotting.linesegments-Tuple"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`linesegments(x, y, z)` / `linesegments(x, y)` / `linesegments(positions)`</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong>: The same as for <a href="functions-overview.html#AbstractPlotting.lines"><code>lines</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.map_once-Tuple{Any,Observables.Observable,Vararg{Observables.Observable,N} where N}" href="#AbstractPlotting.map_once-Tuple{Any,Observables.Observable,Vararg{Observables.Observable,N} where N}"><code>AbstractPlotting.map_once</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map_once(closure, inputs::Node....)::Node</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.</p><p>``` function test(s1::Node)     s3 = map<em>once(x-&gt; (println(&quot;1 &quot;, x); x), s1)     s3 = map</em>once(x-&gt; (println(&quot;2 &quot;, x); x), s1)</p><p>end test(Node(1), Node(2))</p><blockquote></blockquote></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/nodes.jl#L60-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple" href="#AbstractPlotting.mesh!-Tuple"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`mesh(x, y, z)`, `mesh(mesh_object)`, `mesh(x, y, z, faces)`, or `mesh(xyz, faces)`</code></pre><p>Plots a 3D mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mesh-Tuple" href="#AbstractPlotting.mesh-Tuple"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`mesh(x, y, z)`, `mesh(mesh_object)`, `mesh(x, y, z, faces)`, or `mesh(xyz, faces)`</code></pre><p>Plots a 3D mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple" href="#AbstractPlotting.meshscatter!-Tuple"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`meshscatter(x, y, z)` / `meshscatter(x, y)` / `meshscatter(positions)`</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.meshscatter-Tuple" href="#AbstractPlotting.meshscatter-Tuple"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`meshscatter(x, y, z)` / `meshscatter(x, y)` / `meshscatter(positions)`</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouse_selection-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.mouse_selection-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.mouse_selection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mouse_selection(scene::Scene)</code></pre><p>Returns the plot that is under the current mouse position</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L31-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouseover-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}" href="#AbstractPlotting.mouseover-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}"><code>AbstractPlotting.mouseover</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mouseover(scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Returns true if the mouse currently hovers any of <code>plots</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouseposition" href="#AbstractPlotting.mouseposition"><code>AbstractPlotting.mouseposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mouseposition(scene = hovered_scene()) -&gt; pos</code></pre><p>Return the current position of the mouse <code>pos</code> in <em>data points</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L99-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.must_update-Tuple{}" href="#AbstractPlotting.must_update-Tuple{}"><code>AbstractPlotting.must_update</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns whether a scene needs to be updated</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L246-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.onpick" href="#AbstractPlotting.onpick"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code>.  Implemented by the backend.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/events.jl#L104-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.onpick-Tuple{Any,Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}" href="#AbstractPlotting.onpick-Tuple{Any,Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">onpick(f, scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Calls <code>f(idx)</code> whenever the mouse is over any of <code>plots</code>. <code>idx</code> is an index, e.g. when over a scatter plot, it will be the index of the hovered element</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L15-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.pick" href="#AbstractPlotting.pick"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Picks a mouse position.  Implemented by the backend.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/events.jl#L99-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}" href="#AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pick(scene::Scene, xy::VecLike)</code></pre><p>Return the plot under pixel position xy</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L82-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Number,Number}" href="#AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Number,Number}"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the plot under pixel position x y</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L74-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Type{Any}, Type{#s156} where #s156&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Type{Any}, Type{#s156} where #s156&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L489-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Wireframe{...}}" href="#AbstractPlotting.plot!-Tuple{Wireframe{...}}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/basic_recipes.jl#L238-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple" href="#AbstractPlotting.poly!-Tuple"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`poly(vertices, indices; kwargs...)`
`poly(points; kwargs...)`
`poly(shape; kwargs...)`</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryTypes</code>), it will plot <code>decompose(shape)</code>.</p><pre><code class="language-none">poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.poly-Tuple" href="#AbstractPlotting.poly-Tuple"><code>AbstractPlotting.poly</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`poly(vertices, indices; kwargs...)`
`poly(points; kwargs...)`
`poly(shape; kwargs...)`</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryTypes</code>), it will plot <code>decompose(shape)</code>.</p><pre><code class="language-none">poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record-NTuple{4,Any}" href="#AbstractPlotting.record-NTuple{4,Any}"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">record(func, scene, path, iter; framerate = 24)</code></pre><p>This is simply a shorthand to wrap a for loop in <code>record</code>.</p><p>Example:</p><pre><code class="language-example">    scene = lines(rand(10))
    record(scene, &quot;test.gif&quot;, 1:100) do i
        scene.plots[:color] = Colors.RGB(i/255, 0, 0) # animate scene
    end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L432-L445">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record-Tuple{Any,Any,Any}" href="#AbstractPlotting.record-Tuple{Any,Any,Any}"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">record(func, scene, path; framerate = 24)
record(func, scene, path, iter; framerate = 24)</code></pre><p>Records the Scene <code>scene</code> after the application of <code>func</code> on it for each element in <code>itr</code> (any iterator).  <code>func</code> must accept an element of <code>itr</code>.</p><p>The animation is then saved to <code>path</code>, with the format determined by <code>path</code>&#39;s extension.  Allowable extensions are:</p><ul><li><code>.mkv</code>  (the default, doesn&#39;t need to convert)</li><li><code>.mp4</code>  (good for Web, most supported format)</li><li><code>.webm</code> (smallest file size)</li><li><code>.gif</code>  (largest file size for the same quality)</li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>Typical usage patterns would look like:</p><pre><code class="language-julia">record(scene, &quot;video.mp4&quot;, itr) do i
    func(i) # or some other manipulation of the Scene
end</code></pre><p>or, for more tweakability,</p><pre><code class="language-julia">record(scene, &quot;test.gif&quot;) do io
    for i = 1:100
        func!(scene)     # animate scene
        recordframe!(io) # record a new frame
    end
end</code></pre><p>If you want a more tweakable interface, consider using <a href="abstractplotting_api.html#AbstractPlotting.VideoStream-Tuple{Scene}"><code>VideoStream</code></a> and <a href="abstractplotting_api.html#FileIO.save-Tuple{String,VideoStream}"><code>save</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">scene = lines(rand(10))
record(scene, &quot;test.gif&quot;) do io
    for i in 1:255
        scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene
        recordframe!(io)
    end
end</code></pre><p>or</p><pre><code class="language-julia">scene = lines(rand(10))
record(scene, &quot;test.gif&quot;, 1:255) do i
    scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L368-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.record_events-Tuple{Any,Scene,String}" href="#AbstractPlotting.record_events-Tuple{Any,Scene,String}"><code>AbstractPlotting.record_events</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">record_events(f, scene::Scene, path::String)</code></pre><p>Records all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L202-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.recordframe!-Tuple{VideoStream}" href="#AbstractPlotting.recordframe!-Tuple{VideoStream}"><code>AbstractPlotting.recordframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">recordframe!(io::VideoStream)</code></pre><p>Adds a video frame to the VideoStream <code>io</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L303-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}" href="#AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}"><code>AbstractPlotting.replace_automatic!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L70-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.replay_events-Tuple{Scene,String}" href="#AbstractPlotting.replay_events-Tuple{Scene,String}"><code>AbstractPlotting.replay_events</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">replay_events(f, scene::Scene, path::String)
replay_events(scene::Scene, path::String)</code></pre><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L224-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.rotate!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}" href="#AbstractPlotting.rotate!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}"><code>AbstractPlotting.rotate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rotate!(scene::Transformable, axis_rot::Quaternion)
rotate!(scene::Transformable, axis_rot::AbstractFloat)
rotate!(scene::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the Scene.  Rotations are all internally converted to <a href="@ref"><code>Quaternion</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L130-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.rotate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T" href="#AbstractPlotting.rotate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T"><code>AbstractPlotting.rotate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rotate!(Accum, scene::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the Scene, by multiplying by the current rotation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L123-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scale!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}" href="#AbstractPlotting.scale!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}"><code>AbstractPlotting.scale!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <a href="@ref"><code>Transformable</code></a> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L97-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple" href="#AbstractPlotting.scatter!-Tuple"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`scatter(x, y, z)` / `scatter(x, y)` / `scatter(positions)`</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatter-Tuple" href="#AbstractPlotting.scatter-Tuple"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`scatter(x, y, z)` / `scatter(x, y)` / `scatter(positions)`</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple" href="#AbstractPlotting.scatterlines!-Tuple"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>lines</code> between sets of x and y coordinates provided, as well as plotting those points using <code>scatter</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scatterlines-Tuple" href="#AbstractPlotting.scatterlines-Tuple"><code>AbstractPlotting.scatterlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>lines</code> between sets of x and y coordinates provided, as well as plotting those points using <code>scatter</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.select_rectangle-Tuple{Any}" href="#AbstractPlotting.select_rectangle-Tuple{Any}"><code>AbstractPlotting.select_rectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong> <code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L124-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series!-Tuple" href="#AbstractPlotting.series!-Tuple"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Series - ?</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.series-Tuple" href="#AbstractPlotting.series-Tuple"><code>AbstractPlotting.series</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Series - ?</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.showgradients-Tuple{AbstractArray{Symbol,1}}" href="#AbstractPlotting.showgradients-Tuple{AbstractArray{Symbol,1}}"><code>AbstractPlotting.showgradients</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">showgradients(
    cgrads::AbstractVector{Symbol};
    h = 0.0, offset = 0.2, textsize = 0.7, 
    resolution = (800, length(cgrads) * 84)
)::Scene</code></pre><p>Plots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/basic_recipes.jl#L854-L863">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.showlibrary-Tuple{Symbol}" href="#AbstractPlotting.showlibrary-Tuple{Symbol}"><code>AbstractPlotting.showlibrary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">showlibrary(lib::Symbol)::Scene</code></pre><p>Shows all colour gradients in the given library. Returns a Scene with these colour gradients arranged as horizontal colourbars.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/basic_recipes.jl#L837-L843">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider!-Tuple" href="#AbstractPlotting.slider!-Tuple"><code>AbstractPlotting.slider!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Slider</code></pre><p>TODO add function signatures TODO add description</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.slider-Tuple" href="#AbstractPlotting.slider-Tuple"><code>AbstractPlotting.slider</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Slider</code></pre><p>TODO add function signatures TODO add description</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.step!-Tuple{Stepper}" href="#AbstractPlotting.step!-Tuple{Stepper}"><code>AbstractPlotting.step!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">step!(s::Stepper)</code></pre><p>steps through a <code>Makie.Stepper</code> and outputs a file with filename <code>filename-step.jpg</code>. This is useful for generating progressive plot examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L189-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines!-Tuple" href="#AbstractPlotting.streamlines!-Tuple"><code>AbstractPlotting.streamlines!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StreamLines</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.streamlines-Tuple" href="#AbstractPlotting.streamlines-Tuple"><code>AbstractPlotting.streamlines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StreamLines</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple" href="#AbstractPlotting.surface!-Tuple"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`surface(x, y, z)`</code></pre><p>Plots a surface, where <code>(x, y, z)</code> are supposed to lie on a grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.surface-Tuple" href="#AbstractPlotting.surface-Tuple"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`surface(x, y, z)`</code></pre><p>Plots a surface, where <code>(x, y, z)</code> are supposed to lie on a grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text!-Tuple" href="#AbstractPlotting.text!-Tuple"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`text(string)`</code></pre><p>Plots a text.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.text-Tuple" href="#AbstractPlotting.text-Tuple"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`text(string)`</code></pre><p>Plots a text.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.title-Tuple{Any,Any}" href="#AbstractPlotting.title-Tuple{Any,Any}"><code>AbstractPlotting.title</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">title(
    [scene=current_scene(), ], string;
    align = (:center, :bottom), textsize = 30, kw...
)</code></pre><p>Add a title with content <code>string</code> to <code>scene</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/title.jl#L2-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_color-Tuple{Any}" href="#AbstractPlotting.to_color-Tuple{Any}"><code>AbstractPlotting.to_color</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_color(color)</code></pre><p>Converts a <code>color</code> symbol (e.g. <code>:blue</code>) to a color RGBA.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_colormap-Tuple{Any}" href="#AbstractPlotting.to_colormap-Tuple{Any}"><code>AbstractPlotting.to_colormap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_colormap(cm[, N = 20])</code></pre><p>Converts a colormap <code>cm</code> symbol (e.g. <code>:Spectral</code>) to a colormap RGB array, where <code>N</code> specifies the number of color points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.translate!-Tuple{AbstractPlotting.Transformable,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.translate!-Tuple{AbstractPlotting.Transformable,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.translate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate!(scene::Transformable, xyz::VecTypes)
translate!(scene::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the Scene, translating it to <code>x, y, z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L167-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.translate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T" href="#AbstractPlotting.translate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T"><code>AbstractPlotting.translate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">translate!(Accum, scene::Transformable, xyz...)</code></pre><p>Translate the scene relative to its current position.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/transformation.jl#L175-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update!-Tuple{Scene}" href="#AbstractPlotting.update!-Tuple{Scene}"><code>AbstractPlotting.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`update!(p::Scene)`</code></pre><p>Updates a <code>Scene</code> and all its children.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L113-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}" href="#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`update_cam!(scene::SceneLike, area)`</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera2d.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`update_cam!(scene::SceneLike)`</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Node</code> pipeline.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera2d.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_limits!" href="#AbstractPlotting.update_limits!"><code>AbstractPlotting.update_limits!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_limits!(scene::Scene, new_limits::HyperRectangle, padding = Vec3f0(0))</code></pre><p>This function updates the limits of the given <code>Scene</code> according to the given HyperRectangle.</p><p>A <code>HyperRectangle</code> is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).</p><p>Such a <code>HyperRectangle</code> can be constructed using the <code>FRect</code> or <code>FRect3D</code> functions that are exported by <code>AbstractPlotting.jl</code>.  See their documentation for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L706-L718">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_limits!-Tuple{Scene}" href="#AbstractPlotting.update_limits!-Tuple{Scene}"><code>AbstractPlotting.update_limits!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update_limits!(scene::Scene)</code></pre><p>This function updates the limits of the <code>Scene</code> passed to it based on its data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L674-L678">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.vbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}" href="#AbstractPlotting.vbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}"><code>AbstractPlotting.vbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vbox(scenes...; parent = Scene(clear = false), kwargs...)</code></pre><p>Lay the given Scenes out on the vertical axis.  For example, two Scenes <code>vbox</code>ed will be placed side-by-side.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L178-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple" href="#AbstractPlotting.volume!-Tuple"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`volume(volume_data)`</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volume-Tuple" href="#AbstractPlotting.volume-Tuple"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`volume(volume_data)`</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple" href="#AbstractPlotting.volumeslices!-Tuple"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VolumeSlices</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.volumeslices-Tuple" href="#AbstractPlotting.volumeslices-Tuple"><code>AbstractPlotting.volumeslices</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VolumeSlices</code></pre><p>TODO add function signatures TODO add descripton</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple" href="#AbstractPlotting.wireframe!-Tuple"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.wireframe-Tuple" href="#AbstractPlotting.wireframe-Tuple"><code>AbstractPlotting.wireframe</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/6c11e7c2c4705a76f581e8a7f453cc714b09cc7c/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.save-Tuple{String,VideoStream}" href="#FileIO.save-Tuple{String,VideoStream}"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">save(path::String, io::VideoStream; framerate = 24)</code></pre><p>Flushes the video stream and converts the file to the extension found in <code>path</code>, which can be one of the following:</p><ul><li><code>.mkv</code>  (the default, doesn&#39;t need to convert)</li><li><code>.mp4</code>  (good for Web, most supported format)</li><li><code>.webm</code> (smallest file size)</li><li><code>.gif</code>  (largest file size for the same quality)</li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>See the docs of <a href="abstractplotting_api.html#AbstractPlotting.VideoStream-Tuple{Scene}"><code>VideoStream</code></a> for how to create a VideoStream. If you want a simpler interface, consider using <a href="animation.html#AbstractPlotting.record"><code>record</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L323-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FileIO.save-Union{Tuple{F}, Tuple{File{F},Scene}} where F" href="#FileIO.save-Union{Tuple{F}, Tuple{File{F},Scene}} where F"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Saves a <code>Scene</code> to file! Allowable formats depend on the backend;</p><ul><li><code>GLMakie</code> allows <code>.png</code>, <code>.jpeg</code>, and <code>.bmp</code>.</li><li><code>CairoMakie</code> allows <code>.svg</code>, <code>pdf</code>, and <code>.jpeg</code>.</li><li><code>WGLMakie</code> allows <code>.png</code>.</li></ul><p>Resolution can be specified, via <code>save(&quot;path&quot;, scene, resolution = (1000, 1000))</code>!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L170-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Observables.on-Tuple{Any,Camera,Vararg{Observables.Observable,N} where N}" href="#Observables.on-Tuple{Any,Camera,Vararg{Observables.Observable,N} where N}"><code>Observables.on</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">on(f, c::Camera, nodes::Node...)</code></pre><p>When mapping over nodes for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@extract-Tuple{Any,Any}" href="#AbstractPlotting.@extract-Tuple{Any,Any}"><code>AbstractPlotting.@extract</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>usage @exctract scene (a, b, c, d)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L125-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@extractvalue-Tuple{Any,Any}" href="#AbstractPlotting.@extractvalue-Tuple{Any,Any}"><code>AbstractPlotting.@extractvalue</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-example">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L156-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@get_attribute-Tuple{Any,Any}" href="#AbstractPlotting.@get_attribute-Tuple{Any,Any}"><code>AbstractPlotting.@get_attribute</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it&#39;s a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-example">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L132-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.@recipe-Tuple{Any,Symbol,Vararg{Symbol,N} where N}" href="#AbstractPlotting.@recipe-Tuple{Any,Symbol,Vararg{Symbol,N} where N}"><code>AbstractPlotting.@recipe</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><strong>Plot Recipes in <code>AbstractPlotting</code></strong></p><p>There&#39;s two types of recipes. <em>Type recipes</em> define a simple mapping from a user defined type to an existing plot type. <em>Full recipes</em> can customize the theme and define a custom plotting function.</p><p><strong>Type recipes</strong></p><p>Type recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:</p><pre><code class="language-none"># All plot types
convert_arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))
# Only for scatter plots
convert_arguments(P::Type{&lt;:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))</code></pre><p>Optionally you may define the default plot type so that <code>plot(x::MyType)</code> will use this:</p><pre><code class="language-none">plottype(::MyType) = Surface</code></pre><p><strong>Full recipes with the <code>@recipe</code> macro</strong></p><p>A full recipe for <code>MyPlot</code> comes in two parts. First is the plot type name, arguments and theme definition which are defined using the <code>@recipe</code> macro. Second is a custom <code>plot!</code> for <code>MyPlot</code>, implemented in terms of the atomic plotting functions.</p><p>We use an example to show how this works:</p><pre><code class="language-none"># arguments (x, y, z) &amp;&amp; theme are optional
@recipe(MyPlot, x, y, z) do scene
    Theme(
        plot_color =&gt; :red
    )
end</code></pre><p>This macro expands to several things. Firstly a type definition:</p><pre><code class="language-none">const MyPlot{ArgTypes} = Combined{myplot, ArgTypes}</code></pre><p>The type parameter of <code>Combined</code> contains the function instead of e.g. a symbol. This way the mapping from <code>MyPlot</code> to <code>myplot</code> is safer and simpler. (The downside is we always need a function <code>myplot</code> - TODO: is this a problem?)</p><p>The following signatures are defined to make <code>MyPlot</code> nice to use:</p><pre><code class="language-none">myplot(args...; kw_args...) = ...
myplot!(scene, args...; kw_args...) = ...
myplot(kw_args::Dict, args...) = ...
myplot!(scene, kw_args::Dict, args...) = ...
#etc (not 100% settled what signatures there will be)</code></pre><p>A specialization of <code>argument_names</code> is emitted if you have an argument list <code>(x,y,z)</code> provided to the recipe macro:</p><pre><code class="language-none">argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</code></pre><p>This is optional but it will allow the use of <code>plot_object[:x]</code> to fetch the first argument from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>, for example. Alternatively you can always fetch the <code>i</code>th argument using <code>plot_object[i]</code>, and if you leave out the <code>(x,y,z)</code>, the default version of <code>argument_names</code> will provide <code>plot_object[:arg1]</code> etc.</p><p>The theme given in the body of the <code>@recipe</code> invocation is inserted into a specialization of <code>default_theme</code> which inserts the theme into any scene that plots <code>Myplot</code>:</p><pre><code class="language-none">function default_theme(scene, ::Myplot)
    Theme(
        plot_color =&gt; :red
    )
end</code></pre><p>As the second part of defining <code>MyPlot</code>, you should implement the actual plotting of the <code>MyPlot</code> object by specializing <code>plot!</code>:</p><pre><code class="language-none">function plot!(plot::MyPlot)
    # normal plotting code, building on any previously defined recipes
    # or atomic plotting operations, and adding to the combined `plot`:
    lines!(plot, rand(10), color = plot[:plot_color])
    plot!(plot, plot[:x], plot[:y])
    plot
end</code></pre><p>It&#39;s possible to add specializations here, depending on the argument <em>types</em> supplied to <code>myplot</code>. For example, to specialize the behavior of <code>myplot(a)</code> when <code>a</code> is a 3D array of floating point numbers:</p><pre><code class="language-none">const MyVolume = MyPlot{Tuple{&lt;:AbstractArray{&lt;: AbstractFloat, 3}}}
argument_names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional
function plot!(plot::MyVolume)
    # plot a volume with a colormap going from fully transparent to plot_color
    volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])
    plot
end</code></pre><p>The docstring given to the recipe will be transferred to the functions it generates.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/recipes.jl#L26-L127">source</a></section><h2><a class="nav-anchor" id="What-isn&#39;t-1" href="#What-isn&#39;t-1">What isn&#39;t</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.automatic" href="#AbstractPlotting.automatic"><code>AbstractPlotting.automatic</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Singleton instance to indicate that an attribute will get calculated automatically</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L457-L459">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_backends" href="#AbstractPlotting.available_backends"><code>AbstractPlotting.available_backends</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Currently available displays by backend</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/display.jl#L6-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Automatic" href="#AbstractPlotting.Automatic"><code>AbstractPlotting.Automatic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type to indicate that an attribute will get calculated automatically</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L452-L454">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.ColorSampler" href="#AbstractPlotting.ColorSampler"><code>AbstractPlotting.ColorSampler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A colorsampler maps numnber values from a certain range to values of a colormap</p><pre><code class="language-none">x = ColorSampler(colormap, (0.0, 1.0))
x[0.5] # returns color at half point of colormap</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L375-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N" href="#AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N"><code>AbstractPlotting.Plot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the Combined type that represents the signature of <code>args</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L455-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}" href="#AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply for return type     (args...,)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L336-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S" href="#AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply for return type PlotSpec</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L345-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.argument_names-Union{Tuple{P}, Tuple{P}} where P&lt;:AbstractPlot" href="#AbstractPlotting.argument_names-Union{Tuple{P}, Tuple{P}} where P&lt;:AbstractPlot"><code>AbstractPlotting.argument_names</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Each argument can be named for a certain plot type <code>P</code>. Falls back to <code>arg1</code>, <code>arg2</code>, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L161-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.atomic_limits-Union{Tuple{Union{MeshScatter{...}, Scatter{...}, Text{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where #s155&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1" href="#AbstractPlotting.atomic_limits-Union{Tuple{Union{MeshScatter{...}, Scatter{...}, Text{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where #s155&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1"><code>AbstractPlotting.atomic_limits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Data limits calculate a minimal boundingbox from the data points in a plot. This doesn&#39;t include any transformations, markers etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/data_limits.jl#L12-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_gradients-Tuple{}" href="#AbstractPlotting.available_gradients-Tuple{}"><code>AbstractPlotting.available_gradients</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L610-L614">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.available_marker_symbols-Tuple{}" href="#AbstractPlotting.available_marker_symbols-Tuple{}"><code>AbstractPlotting.available_marker_symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">available_marker_symbols()</code></pre><p>Displays all available marker symbols.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L729-L733">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Tuple{Any,Any}" href="#AbstractPlotting.calculated_attributes!-Tuple{Any,Any}"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`calculated_attributes!(trait::Type{&lt;: AbstractPlot}, plot)`</code></pre><p>trait version of calculated_attributes</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L245-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Union{Tuple{T}, Tuple{T}} where T" href="#AbstractPlotting.calculated_attributes!-Union{Tuple{T}, Tuple{T}} where T"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`calculated_attributes!(plot::AbstractPlot)`</code></pre><p>Fill in values that can only be calculated when we have all other attributes filled</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L238-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.cam3d_turntable!-Tuple{Any}" href="#AbstractPlotting.cam3d_turntable!-Tuple{Any}"><code>AbstractPlotting.cam3d_turntable!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cam3d_turntable!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code>, which rotates around the plot&#39;s axis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera3d.jl#L56-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.close2square-Tuple{Real}" href="#AbstractPlotting.close2square-Tuple{Real}"><code>AbstractPlotting.close2square</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns (N1, N2) with <code>N1 x N2 == n</code>. N2 might become 1</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L347-L349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.colorswatch" href="#AbstractPlotting.colorswatch"><code>AbstractPlotting.colorswatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Colorswatch</code></pre><p>TODO add function signatures TODO add description</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/gui.jl#L332-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.current_scene-Tuple{}" href="#AbstractPlotting.current_scene-Tuple{}"><code>AbstractPlotting.current_scene</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the current active scene (the last scene that got created)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L316-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}" href="#AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}"><code>AbstractPlotting.default_plot_signatures</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> default_plot_signatures(funcname, PlotType)</code></pre><p>Creates all the different overloads for <code>funcname</code> that need to be supported for the plotting frontend! Since we add all these signatures to different functions, we make it reusable with this function. The <code>Core.@__doc__</code> macro transfers the docstring given to the Recipe into the functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/recipes.jl#L3-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.default_printer-Tuple{Any}" href="#AbstractPlotting.default_printer-Tuple{Any}"><code>AbstractPlotting.default_printer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">default_printer(v)</code></pre><p>Prints v rounded to three digits.  Here, <code>v</code> can be of any type accepted by <code>round</code>, which includes Real, Complex and many others.  To use your own custom datatype it is sufficient to define Base.round(x::NewType, r::RoundingMode).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/gui.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.detach!-Tuple{Combined}" href="#AbstractPlotting.detach!-Tuple{Combined}"><code>AbstractPlotting.detach!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Remove <code>combined</code> from the current parent, and add it to a new subscene of the parent scene. Returns the new parent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/types.jl#L412-L415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.dont_touch-Union{Tuple{N}, Tuple{GeometryTypes.GeometryPrimitive{N,T} where T,GeometryTypes.GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where N" href="#AbstractPlotting.dont_touch-Union{Tuple{N}, Tuple{GeometryTypes.GeometryPrimitive{N,T} where T,GeometryTypes.GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where N"><code>AbstractPlotting.dont_touch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dont_touch(
    parent::GeometryPrimitive{N}, child::GeometryPrimitive{N},
    pad::Vec{N}
) where N</code></pre><p>Moves <code>child</code> so that it doesn&#39;t touch parent. Leaves a gap to parent defined by <code>pad</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L64-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1" href="#AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1"><code>AbstractPlotting.elconvert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Converts the elemen array type to <code>T1</code> without making a copy if the element type matches</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L6-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N" href="#AbstractPlotting.fit_factor-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>AbstractPlotting.fit_factor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit_factor(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the scaling one needs to apply to lims to fit <code>rect</code> without changing aspect ratio. Returns float scaling and the full strech as given by <a href="abstractplotting_api.html#AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>fit_factor_stretch</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L96-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N" href="#AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N"><code>AbstractPlotting.fit_factor_stretch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit_factor_stretch(rect, lims::NTuple{N}) where N</code></pre><p>Calculates the stretch factor to fill <code>rect</code> in all dimension. Returns a stretch <code>N</code> dimensional fit factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L81-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.fit_ratio-Tuple{Any,Any}" href="#AbstractPlotting.fit_ratio-Tuple{Any,Any}"><code>AbstractPlotting.fit_ratio</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit_ratio(rect, lims)</code></pre><p>Calculates the ratio one needs to stretch <code>lims</code> in order to get the same aspect ratio</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L108-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.flatten_combined" href="#AbstractPlotting.flatten_combined"><code>AbstractPlotting.flatten_combined</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Flattens all the combined plots and returns a Vector of Atomic plots</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L426-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T" href="#AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T"><code>AbstractPlotting.from_dict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">from_dict(::Type{T}, dict)</code></pre><p>Creates the type <code>T</code> from the fields in dict. Automatically converts to the correct node types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L205-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T" href="#AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T"><code>AbstractPlotting.frustum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Create view frustum

Parameters
----------
    left : float
     Left coordinate of the field of view.
    right : float
     Left coordinate of the field of view.
    bottom : float
     Bottom coordinate of the field of view.
    top : float
     Top coordinate of the field of view.
    znear : float
     Near coordinate of the field of view.
    zfar : float
     Far coordinate of the field of view.

Returns
-------
    M : array
     View frustum matrix (4x4).</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/projection_math.jl#L55-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.getscreen-Tuple{Scene}" href="#AbstractPlotting.getscreen-Tuple{Scene}"><code>AbstractPlotting.getscreen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getscreen(scene::Scene)</code></pre><p>Gets the current screen a scene is associated with. Returns nothing if not yet displayed on a screen.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}, Tuple{AbstractArray{T,N} where N,AbstractFloat,Any}} where T" href="#AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}, Tuple{AbstractArray{T,N} where N,AbstractFloat,Any}} where T"><code>AbstractPlotting.interpolated_getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">interpolated_getindex(cmap::AbstractArray, value::AbstractFloat, norm = (0.0, 1.0))</code></pre><p>Like getindex, but accepts values between 0..1 and interpolates those to the full range. You can use <code>norm</code>, to change the range of 0..1 to whatever you want.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T" href="#AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T"><code>AbstractPlotting.lookat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>view = lookat(eyeposition, lookat, up)</code> creates a view matrix with the eye located at <code>eyeposition</code> and looking at position <code>lookat</code>, with the top of the window corresponding to the direction <code>up</code>. Only the component of <code>up</code> that is perpendicular to the vector pointing from <code>eyeposition</code> to <code>lookat</code> will be used.  All inputs must be supplied as 3-vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/projection_math.jl#L121-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys!-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N" href="#AbstractPlotting.mergekeys!-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N"><code>AbstractPlotting.mergekeys!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mergekeys!(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mergekeys-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N" href="#AbstractPlotting.mergekeys-Union{Tuple{N}, Tuple{Tuple{Vararg{Symbol,N}},Attributes,Attributes}} where N"><code>AbstractPlotting.mergekeys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mergekeys(keys::NTuple{N, Symbol}, target::Attributes, source::Attributes)</code></pre><p>Merges only <code>keys</code> from <code>source</code> into <code>target</code>. Creates a copy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.mouse_in_scene-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.mouse_in_scene-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.mouse_in_scene</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mouse_in_scene(scene::Scene)</code></pre><p>returns the mouseposition relative to <code>scene</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L62-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.move_from_touch-Union{Tuple{T}, Tuple{N}, Tuple{GeometryTypes.GeometryPrimitive{N,T},GeometryTypes.GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where T where N" href="#AbstractPlotting.move_from_touch-Union{Tuple{T}, Tuple{N}, Tuple{GeometryTypes.GeometryPrimitive{N,T},GeometryTypes.GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where T where N"><code>AbstractPlotting.move_from_touch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">move_from_touch(
    parent::GeometryPrimitive{N, T}, child::GeometryPrimitive{N},
    pad::Vec{N}
) where {N, T}</code></pre><p>calculates how much <code>child</code> rectangle needs to move to not touch the <code>parent</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/layouting.jl#L41-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.notify!-Tuple{Observables.Observable}" href="#AbstractPlotting.notify!-Tuple{Observables.Observable}"><code>AbstractPlotting.notify!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Pushes an updates to all listeners of <code>node</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/basic_recipes/basic_recipes.jl#L371-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>proj = perspectiveprojection([T], fovy, aspect, znear, zfar)</code> defines a projection matrix with a given angular field-of-view <code>fovy</code> along the y-axis (measured in degrees), the specified <code>aspect</code> ratio, and near and far clipping planes <code>znear</code>, <code>zfar</code>. Optionally specify the element type <code>T</code> of the matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/projection_math.jl#L89-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{GeometryTypes.SimpleRectangle,T,T,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{GeometryTypes.SimpleRectangle,T,T,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>proj = perspectiveprojection([T], rect, fov, near, far)</code> defines the projection ratio in terms of the rectangular view size <code>rect</code> rather than the aspect ratio.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/projection_math.jl#L107-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plots_from_camera-Tuple{Scene}" href="#AbstractPlotting.plots_from_camera-Tuple{Scene}"><code>AbstractPlotting.plots_from_camera</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Fetches all plots sharing the same camera</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L414-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plottype-Tuple" href="#AbstractPlotting.plottype-Tuple"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">`plot_type(plot_args...)`</code></pre><p>The default plot type for any argument is <code>lines</code>. Any custom argument combination that has only one meaningful way to be plotted should overload this. e.g.:</p><pre><code class="language-example">    # make plot(rand(5, 5, 5)) plot as a volume
    plottype(x::Array{&lt;: AbstractFlot, 3}) = Volume</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L420-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{#s154} where #s154&lt;:(Combined{Any,T} where T),Type{#s153} where #s153&lt;:(Combined{T,T1} where T1)}} where T" href="#AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{#s154} where #s154&lt;:(Combined{Any,T} where T),Type{#s153} where #s153&lt;:(Combined{T,T1} where T1)}} where T"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">plottype(P1::Type{&lt;: Combined{T1}}, P2::Type{&lt;: Combined{T2}})</code></pre><p>Chooses the more concrete plot type ```example function convert_arguments(P::PlotFunc, args...)     ptype = plottype(P, Lines)     ... end</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L441-L450">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.primary_resolution-Tuple{}" href="#AbstractPlotting.primary_resolution-Tuple{}"><code>AbstractPlotting.primary_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the resolution of the primary monitor. If the primary monitor can&#39;t be accessed, returns (1920, 1080) (full hd)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L291-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.print_rec" href="#AbstractPlotting.print_rec"><code>AbstractPlotting.print_rec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">print_rec(io::IO, dict, indent::Int = 1[; extended = false])</code></pre><p>Traverses a dictionary <code>dict</code> and recursively print out its keys and values in a nicely-indented format.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L208-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.raw_boundingbox-Tuple{Union{Image{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Text{...}} where Arg}" href="#AbstractPlotting.raw_boundingbox-Tuple{Union{Image{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Text{...}} where Arg}"><code>AbstractPlotting.raw_boundingbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Calculates the exact boundingbox of a Scene/Plot, without considering any transformation</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/layouting/boundingbox.jl#L2-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.reasonable_resolution-Tuple{}" href="#AbstractPlotting.reasonable_resolution-Tuple{}"><code>AbstractPlotting.reasonable_resolution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns a reasonable resolution for the main monitor. (right now just half the resolution of the main monitor)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/scenes.jl#L309-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}" href="#AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}"><code>AbstractPlotting.resample</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">resample(A::AbstractVector, len::Integer)</code></pre><p>Resample a vector with linear interpolation to have length <code>len</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L24-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.resampled_colors-Tuple{Any,Integer}" href="#AbstractPlotting.resampled_colors-Tuple{Any,Integer}"><code>AbstractPlotting.resampled_colors</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">resampled_colors(attributes::Attributes, levels::Integer)</code></pre><p>Resample the color attribute from <code>attributes</code>. Resamples <code>:colormap</code> if present, or repeats <code>:color</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/utilities/utilities.jl#L33-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}" href="#AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}"><code>AbstractPlotting.safe_off</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Observables.off but without throwing an error</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/nodes.jl#L45-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.screen_relative-Tuple{Scene,Any}" href="#AbstractPlotting.screen_relative-Tuple{Scene,Any}"><code>AbstractPlotting.screen_relative</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Normalizes mouse position relative to the screen rectangle</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/interactive_api.jl#L92-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.sig_printer-Tuple{Real}" href="#AbstractPlotting.sig_printer-Tuple{Real}"><code>AbstractPlotting.sig_printer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sig_printer(v::Real)</code></pre><p>Prints the first three significant digits of <code>v</code> in scientific notation.</p><pre><code class="language-julia-repl">julia&gt; -5:5 .|&gt; exp .|&gt; sig_printer
11-element Array{String,1}:
 &quot;6.74e-03&quot;
 &quot;1.83e-02&quot;
 &quot;4.98e-02&quot;
 &quot;1.35e-01&quot;
 &quot;3.68e-01&quot;
 &quot;1.00e+00&quot;
 &quot;2.72e+00&quot;
 &quot;7.39e+00&quot;
 &quot;2.01e+01&quot;
 &quot;5.46e+01&quot;
 &quot;1.48e+02&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interaction/gui.jl#L10-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_func-Union{Tuple{Type{#s155} where #s155&lt;:AbstractPlot{F}}, Tuple{F}} where F" href="#AbstractPlotting.to_func-Union{Tuple{Type{#s155} where #s155&lt;:AbstractPlot{F}}, Tuple{F}} where F"><code>AbstractPlotting.to_func</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_func(Typ)</code></pre><p>Maps the input of a Type name to its cooresponding function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L174-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{#s155,2} where #s155&lt;:ColorTypes.Colorant}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{#s155,2} where #s155&lt;:ColorTypes.Colorant}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Any AbstractMatrix{&lt;: Colorant} or other image type</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L776-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Vector of anything that is accepted as a single marker will give each point it&#39;s own marker. Note that it needs to be a uniform vector with the same element type!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L797-L800">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Array{#s155,2} where #s155&lt;:AbstractFloat}" href="#AbstractPlotting.to_spritemarker-Tuple{Array{#s155,2} where #s155&lt;:AbstractFloat}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Matrix of AbstractFloat will be interpreted as a distancefield (negative numbers outside shape, positive inside)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L771-L773">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Char}" href="#AbstractPlotting.to_spritemarker-Tuple{Char}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_spritemarker(b, marker::Char)</code></pre><p>Any <code>Char</code>, including unicode</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L764-L768">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{GeometryTypes.HyperSphere{2,T} where T}" href="#AbstractPlotting.to_spritemarker-Tuple{GeometryTypes.HyperSphere{2,T} where T}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_spritemarker(b, x::Circle)</code></pre><p><code>GeometryTypes.Circle(Point2(...), radius)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L743-L747">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Symbol}" href="#AbstractPlotting.to_spritemarker-Tuple{Symbol}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A <code>Symbol</code> - Available options can be printed with <code>available_marker_symbols()</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L781-L783">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Type{#s155} where #s155&lt;:(GeometryTypes.HyperSphere{2,T} where T)}" href="#AbstractPlotting.to_spritemarker-Tuple{Type{#s155} where #s155&lt;:(GeometryTypes.HyperSphere{2,T} where T)}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_spritemarker(b, ::Type{Circle})</code></pre><p><code>Type{GeometryTypes.Circle}</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L750-L754">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Type{#s155} where #s155&lt;:GeometryTypes.SimpleRectangle}" href="#AbstractPlotting.to_spritemarker-Tuple{Type{#s155} where #s155&lt;:GeometryTypes.SimpleRectangle}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_spritemarker(b, ::Type{Rectangle})</code></pre><p><code>Type{GeometryTypes.Rectangle}</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/conversions.jl#L756-L760">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_string-Tuple{Function}" href="#AbstractPlotting.to_string-Tuple{Function}"><code>AbstractPlotting.to_string</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_string(func)</code></pre><p>Turns the input of a function name or plot Type into a string.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L195-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.to_type-Tuple{Function}" href="#AbstractPlotting.to_type-Tuple{Function}"><code>AbstractPlotting.to_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_type(func)</code></pre><p>Maps the input of a function name to its cooresponding Type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/documentation/documentation.jl#L186-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.used_attributes</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_attributes(args...) = ()</code></pre><p>function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Usage:</p><pre><code class="language-example">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn&#39;t happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_arguments(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/interfaces.jl#L313-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.zoom!-Tuple{Any,Any,Any,Bool}" href="#AbstractPlotting.zoom!-Tuple{Any,Any,Any,Bool}"><code>AbstractPlotting.zoom!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">zoom!(scene, point, zoom_step)</code></pre><p>Zooms the camera of <code>scene</code> in towards <code>point</code> by a factor of <code>zoom_step</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/1fc489aade41bbddd3cd3ba67b505566f0b57da9/src/camera/camera3d.jl#L206-L210">source</a></section><footer><hr/><a class="previous" href="devdocs.html"><span class="direction">Previous</span><span class="title">Devdocs</span></a></footer></article></body></html>
