<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scenes · Makie.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Makie.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="basic-tutorials.html">Tutorial</a></li><li><a class="toctext" href="statsmakie.html">StatsMakie Tutorial</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="interaction.html">Interaction</a></li><li><a class="toctext" href="functions-overview.html">Plotting functions overview</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="interaction.html">Interaction</a></li></ul></li><li><span class="toctext">Documentation</span><ul><li class="current"><a class="toctext" href="scenes.html">Scenes</a><ul class="internal"><li><a class="toctext" href="#What-is-a-Scene?-1">What is a <code>Scene</code>?</a></li><li><a class="toctext" href="#Subscenes-1">Subscenes</a></li><li><a class="toctext" href="#Current-Scene-1">Current Scene</a></li><li><a class="toctext" href="#Modifying-the-Scene-1">Modifying the Scene</a></li><li><a class="toctext" href="#Updating-the-Scene-1">Updating the Scene</a></li><li><a class="toctext" href="#Events-1">Events</a></li></ul></li><li><a class="toctext" href="signatures.html">Plot function signatures</a></li><li><a class="toctext" href="plot-attributes.html">Plot attributes</a></li><li><a class="toctext" href="colors.html">Colors</a></li><li><a class="toctext" href="theming.html">Config file</a></li><li><a class="toctext" href="cameras.html">Cameras</a></li><li><a class="toctext" href="backends.html">Backends</a></li><li><a class="toctext" href="axis.html">Axis</a></li><li><a class="toctext" href="recipes.html">Plot Recipes</a></li><li><a class="toctext" href="output.html">Output</a></li><li><a class="toctext" href="troubleshooting.html">Troubleshooting</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="why-makie.html">Why <code>Makie</code>?</a></li><li><a class="toctext" href="devdocs.html">Devdocs</a></li><li><a class="toctext" href="gallery.html">MakieGallery</a></li><li><a class="toctext" href="abstractplotting_api.html">AbstractPlotting Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Documentation</li><li><a href="scenes.html">Scenes</a></li></ul><a class="edit-page" href="https://github.com/JuliaPlots/MakieGallery.jl/blob/master/docs/src/scenes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Scenes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Scenes-1" href="#Scenes-1">Scenes</a></h1><h2><a class="nav-anchor" id="What-is-a-Scene?-1" href="#What-is-a-Scene?-1">What is a <code>Scene</code>?</a></h2><p>A <code>Scene</code> is basically a container for <code>Plot</code>s and other <code>Scene</code>s.  <code>Scenes</code> have <code>Plot</code>s (including an <code>Axis</code> if <code>show_axis = true</code>) and <code>Subscenes</code> associated with them.  Every Scene has a transformation, made up of <em>scale</em>, <em>translation</em>, and <em>rotation</em>.</p><p>Plots associated with a Scene can be accessed through <code>scene.plots</code>, which returns an Array of the plots associated with the <code>Scene</code>.  Note that if <code>scene</code> has no plots (if it was created by layouting, or is an empty scene), then <code>scene.plots</code> will be a <em>0-element array</em>!</p><p>A Scene&#39;s subscenes (also called children) can be accessed through <code>scene.children</code>.  This will return an Array of the <code>Scene</code>&#39;s child scenes.  A child scene can be created by <code>childscene = Scene(parentscene)</code>.</p><p>Any <code>Scene</code> with an axis also has a <code>camera</code> associated with it; this can be accessed through <code>scene.camera</code>, and its controls through <code>scene.camera.cameracontrols</code>.  More documentation about these is in the <a href="@ref">Cameras</a> section.</p><h2><a class="nav-anchor" id="Subscenes-1" href="#Subscenes-1">Subscenes</a></h2><p>A subscene is no different than a normal Scene, except that it is linked to a &quot;parent&quot; Scene.  It inherits the transformations of the parent Scene, but can then be transformed independently of it.</p><p>&lt;!–TODO add universe example here–&gt;</p><h2><a class="nav-anchor" id="Current-Scene-1" href="#Current-Scene-1">Current Scene</a></h2><p>Knowing what Scene you are working with at any given moment is paramount as you work with more complex Makie implimentations containing multiple Scenes. You can check your current scene by doing <code>AbstractPlotting.current_scene()</code> which will return the current active scene (the last scene that got created). </p><h2><a class="nav-anchor" id="Modifying-the-Scene-1" href="#Modifying-the-Scene-1">Modifying the Scene</a></h2><p>Makie offers mutation functions to scale, translate and rotate your Scenes on the fly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.translate!" href="#AbstractPlotting.translate!"><code>AbstractPlotting.translate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">translate!(scene::Transformable, xyz::VecTypes)
translate!(scene::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the Scene, translating it to <code>x, y, z</code>.</p></div></div><div><div><pre><code class="language-julia">translate!(Accum, scene::Transformable, xyz...)</code></pre><p>Translate the scene relative to its current position.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.rotate!" href="#AbstractPlotting.rotate!"><code>AbstractPlotting.rotate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rotate!(Accum, scene::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the Scene, by multiplying by the current rotation.</p></div></div><div><div><pre><code class="language-julia">rotate!(scene::Transformable, axis_rot::Quaternion)
rotate!(scene::Transformable, axis_rot::AbstractFloat)
rotate!(scene::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the Scene.  Rotations are all internally converted to <a href="@ref"><code>Quaternion</code></a>s.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.scale!" href="#AbstractPlotting.scale!"><code>AbstractPlotting.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <a href="abstractplotting_api.html#AbstractPlotting.Transformable"><code>Transformable</code></a> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div></div></section><h2><a class="nav-anchor" id="Updating-the-Scene-1" href="#Updating-the-Scene-1">Updating the Scene</a></h2><p>When the Scene is changed, you may need to update several aspects of it.   Makie provides three main updating functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update!" href="#AbstractPlotting.update!"><code>AbstractPlotting.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">`update!(p::Scene)`</code></pre><p>Updates a <code>Scene</code> and all its children. Update will perform the following operations for every scene:</p><pre><code class="language-julia">if !scene.raw[]
    scene.update_limits[] &amp;&amp; update_limits!(scene)
    scene.scale_plot[] &amp;&amp; scale_scene!(scene)
    scene.center[] &amp;&amp; center!(scene)
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_limits!" href="#AbstractPlotting.update_limits!"><code>AbstractPlotting.update_limits!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_limits!(scene::Scene, limits::Union{Automatic, Rect} = scene.limits[], padding = scene.padding[])</code></pre><p>This function updates the limits of the <code>Scene</code> passed to it based on its data. If an actual limit is set by the theme or its attributes (scene.limits !== automatic), it will not update the limits. Call update_limits!(scene, automatic) for that.</p></div></div><div><div><pre><code class="language-julia">update_limits!(scene::Scene, new_limits::HyperRectangle, padding = Vec3f0(0))</code></pre><p>This function updates the limits of the given <code>Scene</code> according to the given HyperRectangle.</p><p>A <code>HyperRectangle</code> is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).</p><p>Such a <code>HyperRectangle</code> can be constructed using the <code>FRect</code> or <code>FRect3D</code> functions that are exported by <code>AbstractPlotting.jl</code>.  See their documentation for more information.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.update_cam!" href="#AbstractPlotting.update_cam!"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">`update_cam!(scene::SceneLike, area)`</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p></div></div><div><div><pre><code class="language-julia">`update_cam!(scene::SceneLike)`</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Node</code> pipeline.</p></div></div><div><div><pre><code class="language-julia">update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f0(0, 0, 1))</code></pre><p>Updates the camera&#39;s controls to point to the specified location.</p></div></div></section><p>In general, <code>update!</code> is to be used to keep data in sync, and <code>update_cam!</code> and <code>update_limits!</code> update the camera and limits respectively (to show all the data).</p><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Scenes have several pre-created event &quot;hooks&quot; (through Observables) that you can handle.  These can be accessed through <code>scene.events</code>, which returns an <code>Events</code> struct:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractPlotting.Events" href="#AbstractPlotting.Events"><code>AbstractPlotting.Events</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This struct provides accessible <code>Observable</code>s to monitor the events associated with a Scene.</p><p><strong>Fields</strong></p><ul><li><p><code>window_area::Observables.Observable{GeometryTypes.HyperRectangle{2,Int64}}</code></p><p>The area of the window in pixels, as an <a href="abstractplotting_api.html#AbstractPlotting.IRect2D"><code>IRect2D</code></a>.</p></li></ul><ul><li><p><code>window_dpi::Observables.Observable{Float64}</code></p><p>The DPI resolution of the window, as a <code>Float64</code>.</p></li></ul><ul><li><p><code>window_open::Observables.Observable{Bool}</code></p><p>The state of the window (open =&gt; true, closed =&gt; false).</p></li></ul><ul><li><p><code>mousebuttons::Observables.Observable{Set{AbstractPlotting.Mouse.Button}}</code></p><p>The pressed mouse buttons. Updates when a mouse button is pressed.</p><p>See also <a href="abstractplotting_api.html#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, ScenePlot},Union{Tuple, Array{T,1} where T}}"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>mouseposition::Observables.Observable{Tuple{Float64,Float64}}</code></p><p>The position of the mouse as a <a href="@ref"><code>Point2</code></a>. Updates whenever the mouse moves.</p></li></ul><ul><li><p><code>mousedrag::Observables.Observable{AbstractPlotting.Mouse.DragEnum}</code></p><p>The</p></li></ul><ul><li><p><code>scroll::Observables.Observable{Tuple{Float64,Float64}}</code></p><p>The direction of scroll</p></li></ul><ul><li><p><code>keyboardbuttons::Observables.Observable{Set{AbstractPlotting.Keyboard.Button}}</code></p><p>See also <a href="abstractplotting_api.html#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, ScenePlot},Union{Tuple, Array{T,1} where T}}"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>unicode_input::Observables.Observable{Array{Char,1}}</code></p></li><li><p><code>dropped_files::Observables.Observable{Array{String,1}}</code></p></li><li><p><code>hasfocus::Observables.Observable{Bool}</code></p><p>Whether the Scene window is in focus or not.</p></li></ul><ul><li><code>entered_window::Observables.Observable{Bool}</code></li></ul></div></div></section><footer><hr/><a class="previous" href="interaction.html"><span class="direction">Previous</span><span class="title">Interaction</span></a><a class="next" href="signatures.html"><span class="direction">Next</span><span class="title">Plot function signatures</span></a></footer></article></body></html>
