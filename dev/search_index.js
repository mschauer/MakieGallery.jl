var documenterSearchIndex = {"docs":
[{"location":"interaction.html#Interaction-1","page":"Interaction","title":"Interaction","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Makie offers a sophisticated referencing system to share attributes across the Scene in your plot. This is great for interaction, animations and saving resources – also if the backend decides to put data on the GPU you might even share those in GPU memory.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Interaction and animations in Makie are handled by using Observables. An \"observable\", called Node in Makie, is a structure that can have its value updated interactively. Interaction, animations and more are done using Nodes and event triggers.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"In this page we overview how the Nodes pipeline works, how event-triggering works, and we give an introduction to the existing \"atomic\" functions for interaction. Examples that use interaction can be found in the Examples/interaction page (see Example Gallery as well).","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Have a peek at Animation for some more information once you're done with this.","category":"page"},{"location":"interaction.html#Node-interaction-pipeline-1","page":"Interaction","title":"Node interaction pipeline","text":"","category":"section"},{"location":"interaction.html#The-Node-structure-1","page":"Interaction","title":"The Node structure","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"A Node is a Julia structure that allows its value to be updated interactively. This means that anything that uses a Node could have its behavior updated interactively, as we will showcase in this page.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Let's start by creating a Node:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"x = Node(0.0) # set up a Node, and give it a default value of 0.0","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"The value of the x can be changed simply using push!:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"julia> x[] = 3.34;\njulia> x\nObservable{Float64} with 0 listeners. Value:\n3.34","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Notice that you can access the value of a Node by indexing it with nothing, i.e. x[]. However, we recommend to use the function to_value to get the value of a Node, because to_value is a general function that works with all types instead of only Nodes. E.g.:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"to_value(x)","category":"page"},{"location":"interaction.html#Nodes-depending-on-other-Nodes-1","page":"Interaction","title":"Nodes depending on other Nodes","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"You can create a node depending on another node using lift:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"f(a) = a^2\ny = lift(a -> f(a), x)","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Now, for every value of the Node x, the derived Node y will hold the value f(x). Updating the value of x will also update the value of y!","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"For example:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"push!(x, 10.0)\nfor i in (x, y)\n    println(to_value(i))\nend","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"That is to say, the Node y maps the function f (which is a -> a^2 in this case) on x whenever the Node x is updated, and updates the corresponding value in y. This is the basis of updating Nodes, and is used for updating plots in Makie. Any plot created based on this pipeline system will get updated whenever the nodes it is based on are updated!","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Note: for now, lift is just an alias for Observables.map, and Node is just an alias for Observables.Observable. This allows decoupling of the APIs.","category":"page"},{"location":"interaction.html#Event-triggering-1","page":"Interaction","title":"Event triggering","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Often it is the case that you want an event to be triggered each time a Node has its value updated. This is done using the on-do block from Observables. For example, the following code block \"triggers\" whenever x's value is changed:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"on(x) do val\n    println(\"x just got the value $val\")\nend","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"As you can see, at we have run this block in Julia, but nothing happened yet. Instead, a function was defined. However, upon doing:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"push!(x, 5.0);","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Boom! The event of the on-do block was triggered! We will be using this in the following paragraphs to establish interactivity.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"For more info please have a look at Observables.","category":"page"},{"location":"interaction.html#Atomic-interaction-functions-1","page":"Interaction","title":"Atomic interaction functions","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"This section overviews some simple and specific functions that make interaction much simpler.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"coming soon...","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"There are three principal plot elements that you can use to make your plot interactive.  These are Slider, textslider, and Button.","category":"page"},{"location":"interaction.html#Slider-1","page":"Interaction","title":"Slider","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Sliders are quite simple to make.  They can be created by a call to the function slider, which usually takes the form:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"sl = slider(range::AbstractVector, raw = true, camera = campixel!, start = somevalue)","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"which makes sl a Scene with only one slider.  The slider will go through range, and start at somevalue.  range must be a subtype of AbstractVector, meaning an Array{T, 1}, a LinRange, et cetera.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"To access the value of the slider as an Observable, we can simply access sl[end][:value], which will return an Observable which will contain the value that the slider is on.  You can then use that Observable in a call to lift.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"A common way to use sliders is to hbox or vbox them with the Scene which depends on them.","category":"page"},{"location":"interaction.html#Button-1","page":"Interaction","title":"Button","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Buttons are clickable markers that can call a function on click, passing to it the number of clicks so far, on each click. A simple exmaple is as follows:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"b1 = button(\"Test Button\")\nlift(b1[end].clicks) do clicks\n    println(\"Button was clicked!\")\n    #Your function goes here\nend","category":"page"},{"location":"interaction.html#Textslider-1","page":"Interaction","title":"Textslider","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"Textsliders are a special case of sliders, with two key diferences - they automatically hbox a label with the slider, and they return a 2-tuple consisting of the Scene of the slider, and its value as an Observable.  Usually, they will be called like so:","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"sl, ol = textslider(-1:0.01:1, \"label\", start = 0)","category":"page"},{"location":"interaction.html#Interaction-using-the-mouse-1","page":"Interaction","title":"Interaction using the mouse","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"A few default Nodes are already implemented in a scene's Events (see them in scene.events), so to use them in your interaction pipeline, you can simply lift them.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"For example, for interaction with the mouse cursor, lift the mouseposition signal.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"pos = lift(scene.events.mouseposition) do mpos\n    # do stuff\nend","category":"page"},{"location":"interaction.html#Interaction-using-the-keyboard-1","page":"Interaction","title":"Interaction using the keyboard","text":"","category":"section"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"To listen to keyboard events, you can lift scene.events.keyboardbuttons, which returns an enum that can be used with some utility functions to implement a keyboard event handler.","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"dir = lift(scene.events.keyboardbuttons) do but\n    global last_dir\n    ispressed(but, Keyboard.left) && return 1\n    ispressed(but, Keyboard.up) && return 2\n    ispressed(but, Keyboard.right) && time[] += 1\n    ispressed(but, Keyboard.down) && return 0\n    last_dir\nend","category":"page"},{"location":"interaction.html#","page":"Interaction","title":"Interaction","text":"<!–TODO make an actual example TODO can we make a keyboard viewer in Makie?–>","category":"page"},{"location":"axis.html#Axis-1","page":"Axis","title":"Axis","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"The axis is just a scene object, making it easy to manipulate and share between plots. Axis objects also contains the mapping you want to apply to the data and can interactively be changed. An Axis object can be created from any boundingbox and inserted into any plot.","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"There are two types of axes: Axis2D and Axis3D.","category":"page"},{"location":"axis.html#Interacting-with-the-Axis-1","page":"Axis","title":"Interacting with the Axis","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"One can quite easily interact with the attributes of the axis like with any other plot.","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"You can access the axis of a scene by doing","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"axis = scene[Axis]","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"The axis attributes are nested, and there are different attributes depending on whether it is an Axis2D or Axis3D object.","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"You can access the nested attributes in multiple ways. Take the nested attribute axis -> :names -> :axisnames, for example:","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"axis[:names, :axisnames] = (\"x\", \"y\", \"z\")\naxis[:names][:axisnames] = (\"x\", \"y\", \"z\")\naxis = (names = (axisnames = (\"x\", \"y\", \"z\"),),)","category":"page"},{"location":"axis.html#Examples-1","page":"Axis","title":"Examples","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Unicode Marker\")","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Axis + Surface\")","category":"page"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Axis theming\")","category":"page"},{"location":"axis.html#Axis2D-1","page":"Axis","title":"Axis2D","text":"","category":"section"},{"location":"axis.html#Axis2D-attributes-groups-1","page":"Axis","title":"Axis2D attributes groups","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nframe See the detailed descriptions for frame attributes.\ngrid See the detailed descriptions for grid attributes.\nnames See the detailed descriptions for names attributes.\nticks See the detailed descriptions for ticks attributes.","category":"page"},{"location":"axis.html#:grid-1","page":"Axis","title":":grid","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nlinecolor Symbol or Colorant. Specifies the color of the grid lines. Can be a color symbol/string like :red, or a Colorant.\nlinestyle \nlinewidth NTuple{2, Number}. Width of the x and y grids.","category":"page"},{"location":"axis.html#:ticks-1","page":"Axis","title":":ticks","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nalign NTuple{2,(:pos, :pos)}. Specify the text alignment for the axis ticks, where :pos can be :left, :center, or :right\nfont NTuple{2,String}. Specifies the font and can name any font available on the system.\ngap Number. Specifies the gap (in pixels) between the axis tick labels and the axes themselves.\nlinecolor NTuple{2,Symbol or Colorant}. Specifies the color of the grid lines. Can be a color symbol/string like :red, or a Colorant.\nlinestyle \nlinewidth NTuple{2,Number}. Width of the axes ticks.\nrotation NTuple{3,Float32}. Specifies the rotations for each axis's ticks, in radians.\ntextcolor NTuple{2,Symbol or Colorant}. Specifies the color of the axes ticks. Can be a color symbol/string like :red, or a Colorant.\ntextsize NTuple{2,Int}. Font pointsize for tick labels.\ntitle_gap Number. Specifies the gap (in pixels) between the axis titles and the axis tick labels.","category":"page"},{"location":"axis.html#:frame-1","page":"Axis","title":":frame","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\narrow_size Number. Size of the axes arrows.\naxis_arrow Bool. Toggles the axes arrows.\naxis_position \nframes NTuple{2,NTuple{2,Bool}}.\nlinecolor Symbol or Colorant. Specifies the color of the grid lines. Can be a color symbol/string like :red, or a Colorant.\nlinestyle \nlinewidth Number. Widths of the axes frame lines.","category":"page"},{"location":"axis.html#:names-1","page":"Axis","title":":names","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nalign (:pos, :pos). Specify the text alignment, where :pos can be :left, :center, or :right.\naxisnames NTuple{2,String}. Specifies the text labels for the axes.\nfont NTuple{2,String}. Specifies the font and can name any font available on the system.\nrotation NTuple{3,Float32}. Specifies the rotations for each axis's label, in radians.\ntextcolor NTuple{2,Symbol or Colorant}. Specifies the color of the axes labels. Can be a color symbol/string like :red, or a Colorant.\ntextsize Integer. Font pointsize for text.","category":"page"},{"location":"axis.html#Axis3D-1","page":"Axis","title":"Axis3D","text":"","category":"section"},{"location":"axis.html#Axis3D-attributes-groups-1","page":"Axis","title":"Axis3D attributes groups","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nframe See the detailed descriptions for frame attributes.\nnames See the detailed descriptions for names attributes.\nscale NTuple{3,Float}. Specifies the scaling for the axes.\nshowaxis NTuple{3,Bool}. Specifies whether to show the axes.\nshowgrid NTuple{3,Bool}. Specifies whether to show the axis grids.\nshowticks NTuple{3,Bool}. Specifies whether to show the axis ticks.\nticks See the detailed descriptions for ticks attributes.","category":"page"},{"location":"axis.html#:ticks-2","page":"Axis","title":":ticks","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nalign NTuple{3,(:pos, :pos)}. Specify the text alignment for the axis ticks, where :pos can be :left, :center, or :right.\nfont NTuple{3,String}. Specifies the font for the axis ticks, and can choose any font available on the system.\ngap Number. Specifies the gap (in pixels) between the axis ticks and the axes themselves.\nrotation NTuple{3,Quaternion{Float32}}. Specifies the rotations for each axis's ticks, in radians.\ntextcolor NTuple{3,Symbol or Colorant}. Specifies the color of the axes ticks. Can be a color symbol/string like :red, or a Colorant.\ntextsize Integer. Font pointsize for text.","category":"page"},{"location":"axis.html#:frame-2","page":"Axis","title":":frame","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\naxiscolor Symbol or Colorant. Specifies the color of the axes. Can be a color symbol/string like :red, or a Colorant.\nlinecolor Symbol or Colorant. Specifies the color of the grid lines. Can be a color symbol/string like :red, or a Colorant.\nlinewidth Number. Width of the axes lines.","category":"page"},{"location":"axis.html#:names-2","page":"Axis","title":":names","text":"","category":"section"},{"location":"axis.html#","page":"Axis","title":"Axis","text":"Symbol Description\nalign NTuple{3,(:pos, :pos)}. Specify the text alignment for the axis labels, where :pos can be :left, :center, or :right.\naxisnames NTuple{3,String}. Specifies the axis labels.\nfont NTuple{3,String}. Specifies the font for the axis labels, and can choose any font available on the system.\ngap Number. Specifies the gap (in pixels) between the axis labels and the axes themselves.\nrotation NTuple{3,Quaternion{Float32}}. Specifies the rotations for each axis's label, in radians.\ntextcolor NTuple{3,Symbol or Colorant}. Specifies the color of the axes labels. Can be a color symbol/string like :red, or a Colorant.\ntextsize NTuple{3,Int}. Font pointsize for axes labels.","category":"page"},{"location":"layout.html#Layouting-1","page":"Layouting","title":"Layouting","text":"","category":"section"},{"location":"layout.html#","page":"Layouting","title":"Layouting","text":"Every object contains a boundingbox and a box indicating where the object should be placed. By default, those boxes are the same. But if you want to move, stretch, scale an object, you can edit the latter. This can be a manual process, or an automatic one. E.g. there are several functions which try to automatically find a layout for certain objects.","category":"page"},{"location":"layout.html#Automatic-interface-1","page":"Layouting","title":"Automatic interface","text":"","category":"section"},{"location":"layout.html#","page":"Layouting","title":"Layouting","text":"layout!(object1, object2, objectN...) 1D grid (alternatively use a vector)\nlayout!(Matrix{Objects}(...)) # 2d Grid\nlayout!(Array{Objects, 3}(...))\n# TODO port layouting options from Plots.jl","category":"page"},{"location":"layout.html#Manual-interface-1","page":"Layouting","title":"Manual interface","text":"","category":"section"},{"location":"layout.html#","page":"Layouting","title":"Layouting","text":"scale!(object, 1f0) # ND version with same scalar for all dimensions\nscale!(object, (1f0, 2f0)) # 2d\nscale!(object, (1f0, 2f0, 3f0)) # 3d\n\nrotate!(object, axis::Vec, amount_degree)\n\ntranslate!(object, amount) # for amount it's the same as with scale!\n\n# boundingbox can be any rect type, e.g. a 3D or 2D HyperRectangle\n# with the effect of exactly fitting `object` into `boundingbox`\nmove!(object, boundingbox)","category":"page"},{"location":"src-functions.html#","page":"-","title":"-","text":"The follow document lists the atomic plotting functions and their usage. These are the most atomic primitives which one can stack together to form more complex plots.","category":"page"},{"location":"src-functions.html#","page":"-","title":"-","text":"For general help about each function, consult the Help functions.","category":"page"},{"location":"src-functions.html#","page":"-","title":"-","text":"See Plot function signatures for the available plot function signatures.","category":"page"},{"location":"src-functions.html#","page":"-","title":"-","text":"See Plot attributes for the available plot attributes.","category":"page"},{"location":"output.html#Output-1","page":"Output","title":"Output","text":"","category":"section"},{"location":"output.html#","page":"Output","title":"Output","text":"Makie overloads the FileIO interface, so it is simple to save Scenes as images.","category":"page"},{"location":"output.html#Static-plots-1","page":"Output","title":"Static plots","text":"","category":"section"},{"location":"output.html#","page":"Output","title":"Output","text":"To save a scene as an image, you can just write e.g.:","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"Makie.save(\"plot.png\", scene)\nMakie.save(\"plot.jpg\", scene)","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"where scene is the scene handle.","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"In the backend, ImageMagick is used for the image format conversions.","category":"page"},{"location":"output.html#Stepper-plots-1","page":"Output","title":"Stepper plots","text":"","category":"section"},{"location":"output.html#","page":"Output","title":"Output","text":"A Stepper is a scene type that simplifies the cumulative plotting, modifying of an existing scene, and saving of scenes. These are great for showing off progressive changes in plots, such as demonstrating the effects of theming or changing data.","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"You can initialize a Stepper by doing:","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"st = Stepper(scene, @replace_with_a_path)","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"and save the scene content & increment the stepper by using:","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"step!(st)","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"@example_database(\"Stepper demo\")","category":"page"},{"location":"output.html#","page":"Output","title":"Output","text":"For more info, consult the Example Gallery.","category":"page"},{"location":"why-makie.html#Why-Makie?-1","page":"Why Makie?","title":"Why Makie?","text":"","category":"section"},{"location":"why-makie.html#","page":"Why Makie?","title":"Why Makie?","text":"Makie is a high level plotting interface for GLVisualize, with a focus on interactivity and speed.","category":"page"},{"location":"why-makie.html#","page":"Why Makie?","title":"Why Makie?","text":"It can also be seen as a prototype for a new design of Plots.jl, since it will implement a very similar interface and incorporate a lot of the ideas.","category":"page"},{"location":"why-makie.html#","page":"Why Makie?","title":"Why Makie?","text":"A fresh start instead of the already available GLVisualize backend for Plots.jl was needed for the following reasons:","category":"page"},{"location":"why-makie.html#","page":"Why Makie?","title":"Why Makie?","text":"Plots.jl was written to create static plots without any interaction. This is deeply reflected in the internal design and makes it hard to integrate the high performance interaction possibilities from GLVisualize.\nPlots.jl has many high level plotting packages as a backend which lead to a very inconsistent design for the backends. For example, there is no straight interface a backend needs to implement. The backend abstraction happens at a very high level and the Plots.jl design relies on the high-level backends to fill in a lot of functionality - which lead to a lot of duplicated work for the lower level backends and a lot of inconsistent behavior since the code isn't shared between backends. It also means that it is a lot of work to maintain a backend.\nThe attributes a plot/series contains and where the default creation happens is opaque and not well documented. Sometimes it's the task of the backend to create defaults for missing attributes, sometimes Plots.jl creates the defaults. A missing attribute is signalled in too many different ways (e.g. false, nothing, \"\") which then needs to be checked and filled in by the backend. This leads to making it very challenging to e.g. find the color of a line for different plot types and creates buggy, inconsistent and messy backend code.\nAs mentioned in point 2, there is not a single consistent low level drawing API. This also influences recipes, since there is not a straight mapping to a low level drawing API and therefore it's not that easy to compose. There should be a finite set of \"atomic\" drawing operations (which can't be decomposed further) which a backend needs to implement and the rest should be implemented via recipes using those atomic operations. So once a backend implements those, it will support all of the plotting operations and only minor maintenance work needs to be done from that point on.\nBackend loading is done in Plots.jl via evaling the backend code. This has at 4 negative consequences:\nBackend code can't be precompiled leading to longer load times\nBackend dependencies are not in the Plots.jl REQUIRE file\nBackend dependencies get loaded via a function that gets evaled, so it's a bit awkward to use those dependencies in the function inside a backend\nWorld age issues because of the eval","category":"page"},{"location":"src-signatures.html#General-function-signatures-and-usage-1","page":"-","title":"General function signatures and usage","text":"","category":"section"},{"location":"src-signatures.html#Create-a-new-plot-inside-a-new-scene-object-1","page":"-","title":"Create a new plot inside a new scene object","text":"","category":"section"},{"location":"src-signatures.html#","page":"-","title":"-","text":"func(args...; kw_args...)","category":"page"},{"location":"src-signatures.html#","page":"-","title":"-","text":"where func are the atomics function, e.g. lines, scatter, surface, etc. For a list of the available atomics functions, see Plotting functions overview.","category":"page"},{"location":"src-signatures.html#Create-a-new-plot-as-a-subscene-of-the-specified-scene-object-1","page":"-","title":"Create a new plot as a subscene of the specified scene object","text":"","category":"section"},{"location":"src-signatures.html#","page":"-","title":"-","text":"func(scene::SceneLike, args...; kw_args...)","category":"page"},{"location":"src-signatures.html#Add-a-plot-in-place-to-the-current_scene()-1","page":"-","title":"Add a plot in-place to the current_scene()","text":"","category":"section"},{"location":"src-signatures.html#","page":"-","title":"-","text":"func!(args...; kw_args...)","category":"page"},{"location":"src-signatures.html#Add-a-plot-in-place-to-the-specified-scene-as-a-subscene-1","page":"-","title":"Add a plot in-place to the specified scene as a subscene","text":"","category":"section"},{"location":"src-signatures.html#","page":"-","title":"-","text":"func!(scene::SceneLike, args...; kw_args...)","category":"page"},{"location":"src-signatures.html#Detailed-function-signatures-1","page":"-","title":"Detailed function signatures","text":"","category":"section"},{"location":"src-signatures.html#","page":"-","title":"-","text":"The input arguments are handled by the convert_arguments function, which handles a large variety of inputs. The signatures accepted by convert_arguments are also those accepted by the plotting functions.","category":"page"},{"location":"src-signatures.html#","page":"-","title":"-","text":"Accepted signatures are as follows:","category":"page"},{"location":"src-axis.html#Axis-1","page":"Axis","title":"Axis","text":"","category":"section"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"The axis is just a scene object, making it easy to manipulate and share between plots. Axis objects also contains the mapping you want to apply to the data and can interactively be changed. An Axis object can be created from any boundingbox and inserted into any plot.","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"There are two types of axes: Axis2D and Axis3D.","category":"page"},{"location":"src-axis.html#Interacting-with-the-Axis-1","page":"Axis","title":"Interacting with the Axis","text":"","category":"section"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"One can quite easily interact with the attributes of the axis like with any other plot.","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"You can access the axis of a scene by doing","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"axis = scene[Axis]","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"The axis attributes are nested, and there are different attributes depending on whether it is an Axis2D or Axis3D object.","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"You can access the nested attributes in multiple ways. Take the nested attribute axis -> :names -> :axisnames, for example:","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"axis[:names, :axisnames] = (\"x\", \"y\", \"z\")\naxis[:names][:axisnames] = (\"x\", \"y\", \"z\")\naxis = (names = (axisnames = (\"x\", \"y\", \"z\"),),)","category":"page"},{"location":"src-axis.html#Examples-1","page":"Axis","title":"Examples","text":"","category":"section"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Unicode Marker\")","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Axis + Surface\")","category":"page"},{"location":"src-axis.html#","page":"Axis","title":"Axis","text":"@example_database(\"Axis theming\")","category":"page"},{"location":"compilation.html#Static-compilation-of-Makie-1","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"","category":"section"},{"location":"compilation.html#Compiling-into-system-image-1","page":"Static compilation of Makie","title":"Compiling into system image","text":"","category":"section"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"You can compile a binary for Makie and add it to your system image for fast plotting times with no JIT overhead, using PackageCompiler.jl.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"To do that, you need to check out the additional packages for precompilation.  Then, you can build a system image using the compile_incremental method.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"What this will do is generate a list of statements to compile using Makie's tests, which are stored in test/runtests.jl.  These tests are exhaustive and use most, if not all, of Makie's functionality.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"To do the precompilation, you need only specify which packages you want to precompile, and PackageCompiler will do the rest.  First, make sure you have PackageCompiler:","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"# add PackageCompiler\nPkg.add(\"PackageCompiler\")\nusing PackageCompiler","category":"page"},{"location":"compilation.html#The-'safe'-method-1","page":"Static compilation of Makie","title":"The 'safe' method","text":"","category":"section"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"Using PackageCompiler is inherently risky, but the chances of it messing up your Julia install if you don't force are minimal.  The safe method outlined here will create a new system image in PackageCompiler'sdirectory, which you can use with Julia by calling julia --sysimage path/to/sysimg.so.  You can also alias this command to something like juliam for ease of access.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"nso, cso = PackageCompiler.compile_incremental(:Makie, :AbstractPlotting, force = false) # can take around ~20 minutes\nnso # path to new system image","category":"page"},{"location":"compilation.html#The-'risky'-method-1","page":"Static compilation of Makie","title":"The 'risky' method","text":"","category":"section"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"There is another approach, which will rewrite your current system image file.  This may brick your Julia install; to revert, consider doing using PackageCompiler; PackageCompiler.revert().  However, note that this is not well tested and you may have to reinstall Julia.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"# Replaces Julia's system image\n# please be very careful with the option below, since this can make your Julia stop working.\n\nPackageCompiler.compile_incremental(:Makie, :AbstractPlotting, force = true)","category":"page"},{"location":"compilation.html#After-precompilation-1","page":"Static compilation of Makie","title":"After precompilation","text":"","category":"section"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"Due to some issues around the precompilation of the display stack, you will have to call AbstractPlotting.__init__() after using AbstractPlotting to display plots.  Alternatively, you can do display(AbstractPlotting.PlotDisplay(), scene); on your Scene to get it to display in a plot window.","category":"page"},{"location":"compilation.html#","page":"Static compilation of Makie","title":"Static compilation of Makie","text":"If you plan to modify or develop Makie, any changes you make to Makie will not propagate normally, since the functions are already in the system image.  You will have to, using Atom (the IDE), eval the changed files.","category":"page"},{"location":"transformations.html#Transformations-1","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"transformations.html#","page":"Transformations","title":"Transformations","text":"Plots, Scenes and Subscenes are all Transformable, meaning that Transformations can be applied to transform them.","category":"page"},{"location":"transformations.html#","page":"Transformations","title":"Transformations","text":"There are three main convenience functions provided for transformation:","category":"page"},{"location":"transformations.html#","page":"Transformations","title":"Transformations","text":"translate!\nrotate!\nscale!","category":"page"},{"location":"transformations.html#","page":"Transformations","title":"Transformations","text":"@example_gallery(\"Tutorial plot transformation\")","category":"page"},{"location":"basic-tutorials.html#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Below is a quick tutorial to help get you started. Note that we assume you have Julia installed and configured already.","category":"page"},{"location":"basic-tutorials.html#Getting-Makie-1","page":"Tutorial","title":"Getting Makie","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"add Makie","category":"page"},{"location":"basic-tutorials.html#Getting-latest-version-of-Makie-1","page":"Tutorial","title":"Getting latest version of Makie","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"add Makie#master AbstractPlotting#master GLMakie#master\ntest Makie","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"The first use of Makie might take a little bit of time, due to precompilation.","category":"page"},{"location":"basic-tutorials.html#Set-the-Scene-1","page":"Tutorial","title":"Set the Scene","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"The Scene object holds everything in a plot, and you can initialize it like so:","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"scene = Scene()","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Note that before you put anything in the scene, it will be blank!","category":"page"},{"location":"basic-tutorials.html#Getting-help-1","page":"Tutorial","title":"Getting help","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"The user-facing functions of Makie are pretty well documented, so you can usually use the help mode in the REPL, or your editor of choice.","category":"page"},{"location":"basic-tutorials.html#Basic-plotting-1","page":"Tutorial","title":"Basic plotting","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Below are some examples of basic plots to help you get oriented.","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"You can put your mouse in the plot window and scroll to zoom. Right click and drag lets you pan around the scene, and left click and drag lets you do selection zoom (in 2D plots), or orbit around the scene (in 3D plots).","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Many of these examples also work in 3D.","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"It is worth noting initally that if you run a Makie.jl example and nothing shows up, you likely need to do display(scene) to render the example on screen.","category":"page"},{"location":"basic-tutorials.html#Scatter-plot-1","page":"Tutorial","title":"Scatter plot","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial simple scatter\")","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial markersize\")","category":"page"},{"location":"basic-tutorials.html#Line-plot-1","page":"Tutorial","title":"Line plot","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial simple line\")","category":"page"},{"location":"basic-tutorials.html#Adding-a-title-1","page":"Tutorial","title":"Adding a title","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial title\")","category":"page"},{"location":"basic-tutorials.html#Adding-to-a-scene-1","page":"Tutorial","title":"Adding to a scene","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial adding to a scene\")","category":"page"},{"location":"basic-tutorials.html#Adjusting-scene-limits-1","page":"Tutorial","title":"Adjusting scene limits","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial adjusting scene limits\")","category":"page"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"You can also use the convenience functions xlims!, ylims! and zlims!.","category":"page"},{"location":"basic-tutorials.html#Basic-theming-1","page":"Tutorial","title":"Basic theming","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"@example_database(\"Tutorial basic theming\")","category":"page"},{"location":"basic-tutorials.html#Statistical-plotting-1","page":"Tutorial","title":"Statistical plotting","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Makie has a lot of support for statistical plots through StatsMakie.jl. See the StatsMakie Tutorial section for more information on this.","category":"page"},{"location":"basic-tutorials.html#Controlling-display-programmatically-1","page":"Tutorial","title":"Controlling display programmatically","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"Scenes will only display by default in global scope.  To make a Scene display when it's defined in a local scope, like a function or a module, you can call display(scene), which will automatically display it in the best available display.   You can force display to the backend's preferred window by calling display(AbstractPlotting.PlotDisplay(), scene).","category":"page"},{"location":"basic-tutorials.html#Saving-plots-1","page":"Tutorial","title":"Saving plots","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"See the Output section.","category":"page"},{"location":"basic-tutorials.html#Animations-1","page":"Tutorial","title":"Animations","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"See the Animation section, as well as the Interaction section.","category":"page"},{"location":"basic-tutorials.html#More-examples-1","page":"Tutorial","title":"More examples","text":"","category":"section"},{"location":"basic-tutorials.html#","page":"Tutorial","title":"Tutorial","text":"See the Example Gallery.","category":"page"},{"location":"functions-overview.html#Plotting-functions-overview-1","page":"Plotting functions overview","title":"Plotting functions overview","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"The follow document lists the atomic plotting functions and their usage. These are the most atomic primitives which one can stack together to form more complex plots.","category":"page"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"For general help about each function, consult the Help functions.","category":"page"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"See Plot function signatures for the available plot function signatures.","category":"page"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"See Plot attributes for the available plot attributes.","category":"page"},{"location":"functions-overview.html#text-1","page":"Plotting functions overview","title":"text","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"text","category":"page"},{"location":"functions-overview.html#AbstractPlotting.text","page":"Plotting functions overview","title":"AbstractPlotting.text","text":"text(string)\n\nPlots a text.\n\nTheme\n\nAvailable attributes and their defaults for Text{...} are: \n\n  align           (:left, :bottom)\n  alpha           1.0\n  color           :black\n  font            \"Dejavu Sans\"\n  linewidth       1\n  overdraw        false\n  position        Float32[0.0, 0.0]\n  rotation        0.0\n  strokecolor     (:black, 0.0)\n  strokewidth     0\n  textsize        20\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 283:283) (Image: library lines 293:308) (Image: library lines 87:116) (Image: library lines 234:259)","category":"page"},{"location":"functions-overview.html#meshscatter-1","page":"Plotting functions overview","title":"meshscatter","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"meshscatter","category":"page"},{"location":"functions-overview.html#AbstractPlotting.meshscatter","page":"Plotting functions overview","title":"AbstractPlotting.meshscatter","text":"meshscatter(positions)\nmeshscatter(x, y)\nmeshscatter(x, y, z)\n\nPlots a mesh for each element in (x, y, z), (x, y), or positions (similar to scatter). markersize is a scaling applied to the primitive passed as marker.\n\nTheme\n\nAvailable attributes and their defaults for MeshScatter{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  marker          GeometryTypes.HyperSphere{3,Float32}(Float32[0.0, 0.0, 0.0], 1.0f0)\n  markersize      0.1\n  overdraw        false\n  rotations       1.0 + 0.0im + 0.0jm + 0.0km\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 30:55) (Image: library lines 136:141) (Image: library lines 155:170) (Image: library lines 336:385) (Image: library lines 415:417) (Image: library lines 594:613) (Image: library lines 120:164) (Image: library lines 3:38) (Image: library lines 4:63)","category":"page"},{"location":"functions-overview.html#scatter-1","page":"Plotting functions overview","title":"scatter","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"scatter","category":"page"},{"location":"functions-overview.html#AbstractPlotting.scatter","page":"Plotting functions overview","title":"AbstractPlotting.scatter","text":"scatter(positions)\nscatter(x, y)\nscatter(x, y, z)\n\nPlots a marker for each element in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for Scatter{...} are: \n\n  alpha             1.0\n  color             :black\n  colormap          :viridis\n  colorrange        AbstractPlotting.Automatic()\n  distancefield     \"nothing\"\n  glowcolor         RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  glowwidth         0.0\n  linewidth         1\n  marker            GeometryTypes.HyperSphere{2,T} where T\n  marker_offset     AbstractPlotting.Automatic()\n  markersize        0.1\n  overdraw          false\n  rotations         Billboard()\n  strokecolor       RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  strokewidth       0.0\n  transform_marker  false\n  transparency      false\n  uv_offset_width   Float32[0.0, 0.0, 0.0, 0.0]\n  visible           true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 5:8) (Image: library lines 12:15) (Image: library lines 35:46) (Image: library lines 105:105) (Image: library lines 207:211) (Image: library lines 249:253) (Image: library lines 272:278) (Image: library lines 312:331) (Image: library lines 335:366) (Image: library lines 380:463) (Image: library lines 145:145) (Image: library lines 149:149) (Image: library lines 392:401) (Image: library lines 404:405) (Image: library lines 457:469) (Image: library lines 473:474) (Image: library lines 3:51) (Image: library lines 55:67) (Image: library lines 71:82) (Image: library lines 220:251) (Image: library lines 255:299) (Image: library lines 4:32) (Image: library lines 37:41) (Image: library lines 61:62) (Image: library lines 66:73) (Image: library lines 77:77) (Image: library lines 85:89) (Image: library lines 4:10) (Image: library lines 4:94) (Image: library lines 102:152)","category":"page"},{"location":"functions-overview.html#mesh-1","page":"Plotting functions overview","title":"mesh","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"mesh","category":"page"},{"location":"functions-overview.html#AbstractPlotting.mesh","page":"Plotting functions overview","title":"AbstractPlotting.mesh","text":"mesh(x, y, z)\nmesh(mesh_object)\nmesh(x, y, z, faces)\nmesh(xyz, faces)\n\nPlots a 3D mesh.\n\nTheme\n\nAvailable attributes and their defaults for Mesh{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 76:89) (Image: library lines 158:181) (Image: library lines 184:184) (Image: library lines 4:14) (Image: library lines 17:25) (Image: library lines 62:65) (Image: library lines 68:69) (Image: library lines 72:81) (Image: library lines 84:85) (Image: library lines 282:288) (Image: library lines 336:385) (Image: library lines 443:449) (Image: library lines 453:453) (Image: library lines 478:487) (Image: library lines 404:547)","category":"page"},{"location":"functions-overview.html#linesegments-1","page":"Plotting functions overview","title":"linesegments","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"linesegments","category":"page"},{"location":"functions-overview.html#AbstractPlotting.linesegments","page":"Plotting functions overview","title":"AbstractPlotting.linesegments","text":"linesegments(positions)\nlinesegments(x, y)\nlinesegments(x, y, z)\n\nPlots a line for each pair of points in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for LineSegments{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 71:76) (Image: library lines 230:238) (Image: library lines 370:371) (Image: library lines 491:539) (Image: library lines 305:399) (Image: library lines 263:288) (Image: library lines 4:63)","category":"page"},{"location":"functions-overview.html#lines-1","page":"Plotting functions overview","title":"lines","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"lines","category":"page"},{"location":"functions-overview.html#AbstractPlotting.lines","page":"Plotting functions overview","title":"AbstractPlotting.lines","text":"lines(positions)\nlines(x, y)\nlines(x, y, z)\n\nCreates a connected line plot for each element in (x, y, z), (x, y) or positions.\n\nTheme\n\nAvailable attributes and their defaults for Lines{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 4:25) (Image: library lines 249:253) (Image: library lines 256:257) (Image: library lines 380:463) (Image: library lines 469:525) (Image: library lines 536:563) (Image: library lines 581:584) (Image: library lines 590:593) (Image: library lines 603:614) (Image: library lines 641:654) (Image: library lines 675:707) (Image: library lines 129:132) (Image: library lines 392:401) (Image: library lines 491:539) (Image: library lines 544:578) (Image: library lines 3:51) (Image: library lines 87:116) (Image: library lines 404:547) (Image: library lines 46:56) (Image: library lines 194:230) (Image: library lines 3:38) (Image: library lines 47:108) (Image: library lines 4:10)","category":"page"},{"location":"functions-overview.html#surface-1","page":"Plotting functions overview","title":"surface","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"surface","category":"page"},{"location":"functions-overview.html#AbstractPlotting.surface","page":"Plotting functions overview","title":"AbstractPlotting.surface","text":"surface(x, y, z)\n\nPlots a surface, where (x, y)  define a grid whose heights are the entries in z.\n\nTheme\n\nAvailable attributes and their defaults for Surface{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 91:99) (Image: library lines 102:110) (Image: library lines 116:123) (Image: library lines 233:241) (Image: library lines 245:260) (Image: library lines 267:278) (Image: library lines 296:332) (Image: library lines 421:438) (Image: library lines 582:590) (Image: library lines 291:305) (Image: library lines 55:86) (Image: library lines 4:10) (Image: library lines 19:23)","category":"page"},{"location":"functions-overview.html#volume-1","page":"Plotting functions overview","title":"volume","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"volume","category":"page"},{"location":"functions-overview.html#AbstractPlotting.volume","page":"Plotting functions overview","title":"AbstractPlotting.volume","text":"volume(volume_data)\n\nPlots a volume. Available algorithms are:\n\n:iso => IsoValue\n:absorption => Absorption\n:mip => MaximumIntensityProjection\n:absorptionrgba => AbsorptionRGBA\n:indexedabsorption => IndexedAbsorptionRGBA\n\nTheme\n\nAvailable attributes and their defaults for Volume{...} are: \n\n  absorption      1.0f0\n  algorithm       :iso\n  alpha           1.0\n  color           \"nothing\"\n  colormap        :viridis\n  colorrange      (0, 1)\n  isorange        0.05f0\n  isovalue        0.5f0\n  linewidth       1\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 59:59) (Image: library lines 175:190) (Image: library lines 650:667) (Image: library lines 676:723) (Image: library lines 19:24) (Image: library lines 28:33) (Image: library lines 37:42)","category":"page"},{"location":"functions-overview.html#heatmap-1","page":"Plotting functions overview","title":"heatmap","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"heatmap","category":"page"},{"location":"functions-overview.html#AbstractPlotting.heatmap","page":"Plotting functions overview","title":"AbstractPlotting.heatmap","text":"heatmap(x, y, values)\nheatmap(values)\n\nPlots a heatmap as an image on x, y (defaults to interpretation as dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Heatmap{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  levels          1\n  linewidth       0.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 66:67) (Image: library lines 30:31) (Image: library lines 109:129) (Image: library lines 190:194) (Image: library lines 268:268) (Image: library lines 335:366) (Image: library lines 175:190) (Image: library lines 55:67) (Image: library lines 220:251) (Image: library lines 603:661) (Image: library lines 4:10) (Image: library lines 19:23)","category":"page"},{"location":"functions-overview.html#image-1","page":"Plotting functions overview","title":"image","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"image","category":"page"},{"location":"functions-overview.html#AbstractPlotting.image","page":"Plotting functions overview","title":"AbstractPlotting.image","text":"image(x, y, image)\nimage(image)\n\nPlots an image on range x, y (defaults to dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Image{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        ColorTypes.RGBA{Float32}[RGBA{Float32}(0.0,0.0,0.0,1.0), RGBA{Float32}(1.0,1.0,1.0,1.0)]\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 30:31) (Image: library lines 99:99) (Image: library lines 207:211) (Image: library lines 4:14) (Image: library lines 17:25) (Image: library lines 116:123) (Image: library lines 233:241) (Image: library lines 404:405) (Image: library lines 93:118) (Image: library lines 19:23)","category":"page"},{"location":"functions-overview.html#contour-1","page":"Plotting functions overview","title":"contour","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"contour","category":"page"},{"location":"functions-overview.html#AbstractPlotting.contour","page":"Plotting functions overview","title":"AbstractPlotting.contour","text":"contour(x, y, z)\n\nCreates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix\n\nTheme\n\nAvailable attributes and their defaults for Contour{...} are: \n\n  alpha           1.0\n  color           \"nothing\"\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  fillrange       false\n  levels          5\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 244:246) (Image: library lines 263:264) (Image: library lines 175:190) (Image: library lines 582:590) (Image: library lines 603:661) (Image: library lines 4:8) (Image: library lines 12:15) (Image: library lines 46:51) (Image: library lines 55:86) (Image: library lines 19:23)","category":"page"},{"location":"functions-overview.html#arrows-1","page":"Plotting functions overview","title":"arrows","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"arrows","category":"page"},{"location":"functions-overview.html#AbstractPlotting.arrows","page":"Plotting functions overview","title":"AbstractPlotting.arrows","text":"`arrows(points, directions; kwargs...)`\n`arrows(x, y, u, v)`\n`arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)`\n`arrows(x, y, z, u, v, w)`\n\nPlots arrows at the specified points with the specified components. u and v are interpreted as vector components (u being the x and v being the y), and the vectors are plotted with the tails at x, y.\n\nIf x, y, u, v are <: AbstractVector, then each 'row' is plotted as a single vector.\n\nIf u, v are <: AbstractMatrix, then x and y are interpreted as specifications for a grid, and u, v are plotted as arrows along the grid.\n\narrows can also work in three dimensions.\n\nTheme\n\nAvailable attributes and their defaults for Arrows{...} are: \n\n  arrowcolor   :black\n  arrowhead    AbstractPlotting.Automatic()\n  arrowsize    0.3\n  arrowtail    \"nothing\"\n  lengthscale  1.0f0\n  linecolor    :black\n  linestyle    \"nothing\"\n  linewidth    1\n  normalize    false\n  scale        Float32[1.0, 1.0, 1.0]\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 66:72) (Image: library lines 76:89) (Image: library lines 641:654) (Image: library lines 217:229) (Image: library lines 245:260)","category":"page"},{"location":"functions-overview.html#barplot-1","page":"Plotting functions overview","title":"barplot","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"barplot","category":"page"},{"location":"functions-overview.html#AbstractPlotting.barplot","page":"Plotting functions overview","title":"AbstractPlotting.barplot","text":"barplot(x, y; kwargs...)\n\nPlots a barplot; y defines the height.  x and y should be 1 dimensional.\n\nTheme\n\nAvailable attributes and their defaults for BarPlot{...} are: \n\n  color        :black\n  colormap     :viridis\n  colorrange   AbstractPlotting.Automatic()\n  fillto       0.0\n  marker       GeometryTypes.HyperRectangle\n  strokecolor  :white\n  strokewidth  0\n  width        AbstractPlotting.Automatic()\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 80:81) (Image: library lines 52:52)","category":"page"},{"location":"functions-overview.html#poly-1","page":"Plotting functions overview","title":"poly","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"poly","category":"page"},{"location":"functions-overview.html#AbstractPlotting.poly","page":"Plotting functions overview","title":"AbstractPlotting.poly","text":"`poly(vertices, indices; kwargs...)`\n`poly(points; kwargs...)`\n`poly(shape; kwargs...)`\n\nPlots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to mesh. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by GeometryTypes), it will plot decompose(shape).\n\npoly(coordinates, connectivity; kwargs...)\n\nPlots polygons, which are defined by coordinates (the coordinates of the vertices) and connectivity (the edges between the vertices).\n\nTheme\n\nAvailable attributes and their defaults for Poly{...} are: \n\n  color         :black\n  colormap      :viridis\n  colorrange    AbstractPlotting.Automatic()\n  linestyle     \"nothing\"\n  overdraw      false\n  shading       false\n  strokecolor   RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)\n  strokewidth   0.0\n  transparency  false\n  visible       true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 57:63) (Image: library lines 133:155) (Image: library lines 230:238) (Image: library lines 87:116) (Image: library lines 168:216)","category":"page"},{"location":"functions-overview.html#band-1","page":"Plotting functions overview","title":"band","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"band","category":"page"},{"location":"functions-overview.html#AbstractPlotting.band","page":"Plotting functions overview","title":"AbstractPlotting.band","text":"band(x, ylower, yupper; kwargs...)\n\nPlots a band from ylower to yupper along x.\n\nTheme\n\nAvailable attributes and their defaults for Band{...} are: \n\n  alpha           1.0\n  color           RGBA{Float32}(1.0f0,0.0f0,0.0f0,0.2f0)\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#slider-1","page":"Plotting functions overview","title":"slider","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"slider","category":"page"},{"location":"functions-overview.html#AbstractPlotting.slider","page":"Plotting functions overview","title":"AbstractPlotting.slider","text":"slider(range; kwargs...)\n\nCreates a slider which slides through the selected range; sliders are discrete. The Slider's value can be accessed through its value field.  For example:\n\nscene = slider(1:10)\nlift(scene[end].value) do val\n    # your function here\nend\n\nTheme\n\nAvailable attributes and their defaults for Slider{...} are: \n\n  backgroundcolor    (:gray, 0.01)\n  buttoncolor        :white\n  buttonsize         15\n  buttonstroke       1.5\n  buttonstrokecolor  :black\n  camera             AbstractPlotting.campixel!\n  position           (0, 0)\n  raw                true\n  slidercolor        (:gray, 0.6)\n  sliderheight       50\n  sliderlength       200\n  start              AbstractPlotting.Automatic()\n  strokecolor        (:black, 0.4)\n  strokewidth        1\n  textcolor          :black\n  textsize           15\n  value              0\n  valueprinter       AbstractPlotting.default_printer\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 71:82) (Image: library lines 120:164) (Image: library lines 255:299) (Image: library lines 305:399) (Image: library lines 404:547) (Image: library lines 551:599) (Image: library lines 47:108)","category":"page"},{"location":"functions-overview.html#vbox-1","page":"Plotting functions overview","title":"vbox","text":"","category":"section"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"vbox","category":"page"},{"location":"functions-overview.html#AbstractPlotting.vbox","page":"Plotting functions overview","title":"AbstractPlotting.vbox","text":"vbox(scenes...; parent = Scene(clear = false), kwargs...)\n\nBox the scenes together on the vertical axis.  For example, two Scenes vboxed will be placed side-by-side. ––––––––––  –––––––––– –                –  –                – –    Scene 1     –  –    Scene 2     – –                –  –                – ––––––––––  ––––––––––\n\n\n\n\n\n","category":"function"},{"location":"functions-overview.html#","page":"Plotting functions overview","title":"Plotting functions overview","text":"(Image: library lines 109:129) (Image: library lines 267:278) (Image: library lines 71:82) (Image: library lines 120:164) (Image: library lines 305:399) (Image: library lines 404:547) (Image: library lines 263:288) (Image: library lines 4:10) (Image: library lines 19:23)","category":"page"},{"location":"reflection.html#Reflection-1","page":"Reflection","title":"Reflection","text":"","category":"section"},{"location":"reflection.html#","page":"Reflection","title":"Reflection","text":"Since objects with links (as explained in Interaction) to each other, all animatable etc, a plot object can become fairly complex. To work against this, there is a rich reflection api, allowing you to look into the scene tree, display what objects are linked and interactively change the attributes.","category":"page"},{"location":"theming.html#Config-file-1","page":"Config file","title":"Config file","text":"","category":"section"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"A configuration file can be used to save theming options. The config file must be global (in joinpath(homedir(), \".config\", \"makie\", \"theme.jl\")). This makes it easier to have a common style for multiple plots without explicitly giving the desired options each time.","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"A config file must return an Attributes object. For example, if the contents of theme.jl is the following:","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"Attributes(\n    font = \"Chilanka\",\n    backgroundcolor = :gray,\n    color = :blue,\n    linestyle = :dot,\n    linewidth = 3\n)","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"then Makie will start with this theme.","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"There are other things that you can configure in this file before returning the Attributes, though.  ","category":"page"},{"location":"theming.html#Resolution-setting-1","page":"Config file","title":"Resolution setting","text":"","category":"section"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"You can set the default resolution, at which Scenes will be displayed, by adding the statement:","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"reasonable_resolution() = (800, 800)","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"before the attributes' declaration.","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"You can also configure your primary resolution, by:","category":"page"},{"location":"theming.html#","page":"Config file","title":"Config file","text":"primary_resolution() = (1920, 1080)","category":"page"},{"location":"scenes.html#Scenes-1","page":"Scenes","title":"Scenes","text":"","category":"section"},{"location":"scenes.html#What-is-a-Scene?-1","page":"Scenes","title":"What is a Scene?","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"A Scene is basically a container for Plots and other Scenes.  Scenes have Plots (including an Axis if show_axis = true) and Subscenes associated with them.  Every Scene has a transformation, made up of scale, translation, and rotation.","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Plots associated with a Scene can be accessed through scene.plots, which returns an Array of the plots associated with the Scene.  Note that if scene has no plots (if it was created by layouting, or is an empty scene), then scene.plots will be a 0-element array!","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"If a scene is not explicitly declared prior to one of the plot! commands being called, a Scene will be created by default as follows:  lines(args...) = lines!(Scene(), args...).","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"In this example, lines becomes the parent of all of the following plot! commands since it was called prior to a Scene being explicitly created.","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"A Scene's subscenes (also called children) can be accessed through scene.children.  This will return an Array of the Scene's child scenes.  A child scene can be created by childscene = Scene(parentscene).","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Any Scene with an axis also has a camera associated with it; this can be accessed through scene.camera, and its controls through scene.camera.cameracontrols.  More documentation about these is in the Cameras section.","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Scene's also have configurable size/resolution. You can set the size in pixels by doing Scene(resolution = (500, 500)).","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Any keyword argument given to the Scene will be propagated to its plots; therefore, you can set the palette or the colormap in the Scene itself.","category":"page"},{"location":"scenes.html#Subscenes-1","page":"Scenes","title":"Subscenes","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"A subscene is no different than a normal Scene, except that it is linked to a \"parent\" Scene.  It inherits the transformations of the parent Scene, but can then be transformed independently of it.","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"<!–TODO add universe example here–>","category":"page"},{"location":"scenes.html#Current-Scene-1","page":"Scenes","title":"Current Scene","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Knowing what Scene you are working with at any given moment is paramount as you work with more complex Makie implimentations containing multiple Scenes. You can check your current scene by doing AbstractPlotting.current_scene() which will return the current active scene (the last scene that got created). ","category":"page"},{"location":"scenes.html#Modifying-the-Scene-1","page":"Scenes","title":"Modifying the Scene","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Makie offers mutation functions to scale, translate and rotate your Scenes on the fly.","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"translate!\nrotate!\nscale!","category":"page"},{"location":"scenes.html#AbstractPlotting.translate!","page":"Scenes","title":"AbstractPlotting.translate!","text":"translate!(scene::Transformable, xyz::VecTypes)\ntranslate!(scene::Transformable, xyz...)\n\nApply an absolute translation to the Scene, translating it to x, y, z.\n\n\n\n\n\ntranslate!(Accum, scene::Transformable, xyz...)\n\nTranslate the scene relative to its current position.\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#AbstractPlotting.rotate!","page":"Scenes","title":"AbstractPlotting.rotate!","text":"rotate!(Accum, scene::Transformable, axis_rot...)\n\nApply a relative rotation to the Scene, by multiplying by the current rotation.\n\n\n\n\n\nrotate!(scene::Transformable, axis_rot::Quaternion)\nrotate!(scene::Transformable, axis_rot::AbstractFloat)\nrotate!(scene::Transformable, axis_rot...)\n\nApply an absolute rotation to the Scene.  Rotations are all internally converted to Quaternions.\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#AbstractPlotting.scale!","page":"Scenes","title":"AbstractPlotting.scale!","text":"scale!(t::Transformable, x, y)\nscale!(t::Transformable, x, y, z)\nscale!(t::Transformable, xyz)\nscale!(t::Transformable, xyz...)\n\nScale the given Transformable (a Scene or Plot) to the given arguments. Can take x, y or x, y, z. This is an absolute scaling, and there is no option to perform relative scaling.\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#Updating-the-Scene-1","page":"Scenes","title":"Updating the Scene","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"When the Scene is changed, you may need to update several aspects of it.   Makie provides three main updating functions:","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"update!\nupdate_limits!\nupdate_cam!","category":"page"},{"location":"scenes.html#AbstractPlotting.update!","page":"Scenes","title":"AbstractPlotting.update!","text":"`update!(p::Scene)`\n\nUpdates a Scene and all its children. Update will perform the following operations for every scene:\n\nif !scene.raw[]\n    scene.update_limits[] && update_limits!(scene)\n    scene.scale_plot[] && scale_scene!(scene)\n    scene.center[] && center!(scene)\nend\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#AbstractPlotting.update_limits!","page":"Scenes","title":"AbstractPlotting.update_limits!","text":"update_limits!(scene::Scene, limits::Union{Automatic, Rect} = scene.limits[], padding = scene.padding[])\n\nThis function updates the limits of the Scene passed to it based on its data. If an actual limit is set by the theme or its attributes (scene.limits !== automatic), it will not update the limits. Call update_limits!(scene, automatic) for that.\n\n\n\n\n\nupdate_limits!(scene::Scene, new_limits::HyperRectangle, padding = Vec3f0(0))\n\nThis function updates the limits of the given Scene according to the given HyperRectangle.\n\nA HyperRectangle is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).\n\nSuch a HyperRectangle can be constructed using the FRect or FRect3D functions that are exported by AbstractPlotting.jl.  See their documentation for more information.\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#AbstractPlotting.update_cam!","page":"Scenes","title":"AbstractPlotting.update_cam!","text":"`update_cam!(scene::SceneLike, area)`\n\nUpdates the camera for the given scene to cover the given area in 2d.\n\n\n\n\n\n`update_cam!(scene::SceneLike)`\n\nUpdates the camera for the given scene to cover the limits of the Scene. Useful when using the Node pipeline.\n\n\n\n\n\nupdate_cam!(scene::Scene, eyeposition, lookat, up = Vec3f0(0, 0, 1))\n\nUpdates the camera's controls to point to the specified location.\n\n\n\n\n\n","category":"function"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"In general, update! is to be used to keep data in sync, and update_cam! and update_limits! update the camera and limits respectively (to show all the data).","category":"page"},{"location":"scenes.html#Events-1","page":"Scenes","title":"Events","text":"","category":"section"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Scenes have several pre-created event \"hooks\" (through Observables) that you can handle.  These can be accessed through scene.events, which returns an Events struct:","category":"page"},{"location":"scenes.html#","page":"Scenes","title":"Scenes","text":"Events","category":"page"},{"location":"scenes.html#AbstractPlotting.Events","page":"Scenes","title":"AbstractPlotting.Events","text":"This struct provides accessible Observables to monitor the events associated with a Scene.\n\nFields\n\nwindow_area::Observables.Observable{GeometryTypes.HyperRectangle{2,Int64}}\nThe area of the window in pixels, as an IRect2D.\n\nwindow_dpi::Observables.Observable{Float64}\nThe DPI resolution of the window, as a Float64.\n\nwindow_open::Observables.Observable{Bool}\nThe state of the window (open => true, closed => false).\n\nmousebuttons::Observables.Observable{Set{AbstractPlotting.Mouse.Button}}\nThe pressed mouse buttons. Updates when a mouse button is pressed.\nSee also ispressed.\n\nmouseposition::Observables.Observable{Tuple{Float64,Float64}}\nThe position of the mouse as a Point2. Updates whenever the mouse moves.\n\nmousedrag::Observables.Observable{AbstractPlotting.Mouse.DragEnum}\nThe\n\nscroll::Observables.Observable{Tuple{Float64,Float64}}\nThe direction of scroll\n\nkeyboardbuttons::Observables.Observable{Set{AbstractPlotting.Keyboard.Button}}\nSee also ispressed.\n\nunicode_input::Observables.Observable{Array{Char,1}}\ndropped_files::Observables.Observable{Array{String,1}}\nhasfocus::Observables.Observable{Bool}\nWhether the Scene window is in focus or not.\n\nentered_window::Observables.Observable{Bool}\n\n\n\n\n\n","category":"type"},{"location":"colors.html#Colors-1","page":"Colors","title":"Colors","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Makie has support for you to color your plots however you want to. You can manipulate the color of a plot by using the color keyword, and change the colormap by using the colormap keyword.","category":"page"},{"location":"colors.html#Colors-2","page":"Colors","title":"Colors","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"For line plots, you can provide a single color or symbol that will color the entire line; or, you can provide an array of values that map to colors using a colormap.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Any color symbol supported by Color.jl is supported, check out their page on named colors to see what you can get away with!  You can also pass RGB or RGBA values.","category":"page"},{"location":"colors.html#Colormaps-1","page":"Colors","title":"Colormaps","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Colormaps are mappings of values to colors.  You can supply the coloring values using the color keyword argument, and the colormap will automatically be adjusted to fit those values.  THe default colormap is viridis, which looks like this:","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Viridis color scheme\")","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"You can copy this code and substitute cmap with any Colormap to show the colormap.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Makie supports multiple colormap libraries.  Currently, support for colormaps provided by PlotUtils is inbuilt, meaning that any colormap symbol that works with Plots will also work with Makie.  Colormaps from the ColorSchemes package can be used by colormap = ColorSchemes.<name of colormap>.colors.  Similarly, colormaps from the PerceptualColourMaps package (which is a superset of the colorcet library) can be used by colormap = PerceptualColourMaps.cgrad(\"<name of colormap>\").  In principle, any Array of RGB values can be used as a colormap.","category":"page"},{"location":"colors.html#Builtins-1","page":"Colors","title":"Builtins","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Color gradients are arranged into color libraries. To get a list of color libraries, use the clibraries function. To get a list of color gradients in each library, call cgradients(library). showlibrary(library) creates a visual representation of color schemes. To change the active library, use clibrary(library). This is only necessary in the case of namespace clashes, e.g. if there are multiple :blues. The gradients can be reversed by Reverse(:<gradient_name>). The clims::NTuple{2,Number} attribute can be used to define the data values that correspond with the ends of the colormap.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"PlotUtils bundles with it colormaps from many libraries.  As of the 16th of March, 2019, those are:","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":":Plots    # default\n:cmocean\n:colorbrewer\n:colorcet","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Again, the clibrary function can be used to change the preferred colour library in case of namespae conflict.  For example, to prefer the use of cmocean colourmaps if available, you might call clibrary(:cmocean) before plotting.","category":"page"},{"location":"colors.html#Libraries-1","page":"Colors","title":"Libraries","text":"","category":"section"},{"location":"colors.html#PLOTS-1","page":"Colors","title":"PLOTS","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"The default library.  Created by Nathaniel J. Smith, Stefan van der Walt, and (in the case of viridis) Eric Firing. Released under CC0 license / public domain dedication. Full license info available here.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Colormap collection\", 1)","category":"page"},{"location":"colors.html#CMOCEAN-1","page":"Colors","title":"CMOCEAN","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Released under The MIT License (MIT) Copyright (c) 2015 Kristen M. Thyng. RGB values were taken from https://github.com/matplotlib/cmocean/tree/master/cmocean/rgb","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Colormap collection\", 2)","category":"page"},{"location":"colors.html#COLORCET-1","page":"Colors","title":"COLORCET","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Released under The MIT License (MIT) Copyright (c) 2015 Peter Kovesi. These are the perceptually correct color maps designed by Peter Kovesi and described in Peter Kovesi. Good Colour Maps: How to Design Them. arXiv:1509.03700 [cs.GR] 2015","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Colormap collection\", 3)","category":"page"},{"location":"colors.html#COLORBREWER-1","page":"Colors","title":"COLORBREWER","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Created by Cynthia Brewer, Mark Harrower, and The Pennsylvania State University. Released under the Apache License, Version 2.0. Full license info available here.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Colormap collection\", 4)","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"note: Note\nDue to the font in the image above, it may be difficult to tell that the yellow-orange-brown gradient, YlOrBr, is not YIOrBr - the second character is an l, not an I.","category":"page"},{"location":"colors.html#MISC-1","page":"Colors","title":"MISC","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Colormap collection\", 5)","category":"page"},{"location":"colors.html#Color-legends-1","page":"Colors","title":"Color legends","text":"","category":"section"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"To show the colormap and its scaling, you can use a color legend.  Color legends can be automatically produced by the colorlegend function, to which a Plot object must be passed.  Its range and the colormap it shows can also be manually altered, as can many of its attributes.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"To simply produce a color legend and plot it to the left of the original plot, you can produce a colorlegend and vbox it.  In the example below, p1 is the initial Scene, with only one plot.","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"scene = vbox(\n  p1,\n  colorlegend(\n    p1[end],            # get Plot object from Scene\n    camera = campixel!, # let vbox decide scene limits\n    raw = true          # no axes, other things as well\n  )\n)","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"Be warned that in its current form, this will look quite small compared to the size of the plot!","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"To fix that, you can theme it, as shown below:","category":"page"},{"location":"colors.html#","page":"Colors","title":"Colors","text":"@example_database(\"Line with varying colors\")","category":"page"},{"location":"troubleshooting.html#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting.html#Installation-issues-1","page":"Troubleshooting","title":"Installation issues","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"Here, we assume you are running Julia on the vanilla system image - no PackageCompiler goodness.  If you are using PackageCompiler, check out the page on compilation.","category":"page"},{"location":"troubleshooting.html#No-Scene-displayed-or-GLMakie-fails-to-build-1","page":"Troubleshooting","title":"No Scene displayed or GLMakie fails to build","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"If Makie builds, but when a plotting, no Scene is displayed, as in:","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> using Makie\n\njulia> lines([0,1], [0,1])\nScene (960px, 540px):\nevents:\n    window_area: GeometryTypes.HyperRectangle{2,Int64}([0, 0], [0, 0])\n    window_dpi: 100.0\n    window_open: false\n    mousebuttons: Set(AbstractPlotting.Mouse.Button[])\n    mouseposition: (0.0, 0.0)\n    mousedrag: notpressed\n    scroll: (0.0, 0.0)\n    keyboardbuttons: Set(AbstractPlotting.Keyboard.Button[])\n    unicode_input: Char[]\n    dropped_files: String[]\n    hasfocus: false\n    entered_window: false\nplots:\n   *Axis2D{...}\n   *Lines{...}\nsubscenes:\n   *scene(960px, 540px)","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"then, your backend may not have built correctly.  By default, Makie will try to use GLMakie as a backend, but if it does not build correctly for whatever reason, then scenes will not be displayed. Ensure that your graphics card supports OpenGL; if it does not (old models, or relatively old integrated graphics cards), then you may want to consider CairoMakie.","category":"page"},{"location":"troubleshooting.html#Plotting-issues-1","page":"Troubleshooting","title":"Plotting issues","text":"","category":"section"},{"location":"troubleshooting.html#Dimension-too-large-1","page":"Troubleshooting","title":"Dimension too large","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"In general, plotting functions tend to plot whatever's given to them as a single texture.  This can lead to GL errors, or OpenGL failing silently.  To circumvent this, one can 'tile' the plots (i.e., assemble them piece-by-piece) to decrease the individual texture size.","category":"page"},{"location":"troubleshooting.html#d-plots-(heatmaps,-images,-etc.)-1","page":"Troubleshooting","title":"2d plots (heatmaps, images, etc.)","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"heatmap(rand(Float32, 24900, 26620))","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"may either fail with an error","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"   Error showing value of type Scene:\nERROR: glTexImage 2D: width too large. Width: 24900\n[...]","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"or fail silently:","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: untiled heatmap)","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"Tiling the plot, as shown below, yields a correct image.","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"sc = Scene()\ndata = rand(Float32, 24900, 26620)\nheatmap!(sc, 1:size(data, 1)÷2, 1:size(data, 2)÷2, data[1:end÷2, 1:end÷2])\nheatmap!(sc, (size(data, 1)÷2 + 1):size(data, 1), 1:size(data, 2)÷2, data[(end÷2 + 1):end, 1:end÷2])\nheatmap!(sc, 1:size(data, 1)÷2, (size(data, 2)÷2 + 1):size(data, 2), data[1:end÷2, (end÷2 + 1):end])\nheatmap!(sc, (size(data, 1)÷2 + 1):size(data, 1), (size(data, 2)÷2 + 1):size(data, 2), \n         data[(end÷2 + 1):end, (end÷2 + 1):end])","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: tiled heatmap)","category":"page"},{"location":"troubleshooting.html#d-plots-(volumes)-1","page":"Troubleshooting","title":"3d plots (volumes)","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"The approach here is similar to that for the 2d plots, except that here there is a helpful function that gives the maximum texture size. You can check the maximum texture size with:","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"using Makie, GLMakie, ModernGL\n# simple plot to open a window (needs to be open for opengl)\ndisplay(scatter(rand(10)))\nglGetIntegerv(GL_MAX_3D_TEXTURE_SIZE)","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"and then just split the volume:","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"vol = rand(506, 720, 1440)\nranges = (1:256, 1:256, 1:256)\nscene = volume(ranges..., vol[ranges...])\nfor i in 1:3\n    global ranges\n    ranges = ntuple(3) do j\n        s = j == i ? last(ranges[j]) : 1\n        e = j == i ? size(vol, j) : last(ranges[j])\n        s:e\n    end\n    volume!(ranges..., vol[ranges...])\nend\nscene","category":"page"},{"location":"troubleshooting.html#General-issues-1","page":"Troubleshooting","title":"General issues","text":"","category":"section"},{"location":"troubleshooting.html#My-font-doesn't-work!-1","page":"Troubleshooting","title":"My font doesn't work!","text":"","category":"section"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"If Makie can't find your font, you can do two things:","category":"page"},{"location":"troubleshooting.html#","page":"Troubleshooting","title":"Troubleshooting","text":"Check that the name matches and that the font is in one of the directories in:\nusing FreeTypeAbstraction; FreeTypeAbstraction.valid_fontpaths\nYou can add a custom font path via the environment variable:\nENV[\"FREETYPE_ABSTRACTION_FONT_PATH\"] = \"/path/to/your/fonts\"\nSpecify the path to the font; instead of font = \"Noto\", you could write joindir(homedir(), \"Noto.ttf\") or something.","category":"page"},{"location":"gallery.html#MakieGallery-1","page":"MakieGallery","title":"MakieGallery","text":"","category":"section"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"MakieGallery.jl is the repo which hosts these docs, as well as the source code for the examples in the Example Gallery.","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"Docs are built using Documenter.jl, and are located in the docs folder.   The raw markdown files from which documentation is generated are located in docs/src, but all the pages are not there; some, like Plotting functions overview, are generated during documentation build.   Those markdown pages have a src- prefix.","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"Examples live in the examples directory, and are organized into several Julia files. Each file is structured into several @blocks which contain @cells.  Each cell contains one example; the syntax is generally:","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"@cell \"$title\" [labels...] begin\n    # example code here\nend","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"The @block is a way to organize many cells which have a common theme or purpose.  The syntax is generally:","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"@block FirstnameLastname [labels...] begin\n    # cells here\nend","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"Blocks are a nice way to preserve authorship and group similar examples.","category":"page"},{"location":"gallery.html#Contributing-Examples-1","page":"MakieGallery","title":"Contributing Examples","text":"","category":"section"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"If you want to add a single example, it's probably best to find a file it fits well in and add a cell.","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"If you want to add multiple examples, you may want to create a block in the appropriate file.","category":"page"},{"location":"gallery.html#","page":"MakieGallery","title":"MakieGallery","text":"Adding interactive examples will mean you need to create a serialized file which stores the input events; this can be done by using the MakieGallery.record_example(title::String) function, and interacting with (and then closing) the Scene.","category":"page"},{"location":"help_functions.html#Help-functions-1","page":"Help functions","title":"Help functions","text":"","category":"section"},{"location":"help_functions.html#help-1","page":"Help functions","title":"help","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"help","category":"page"},{"location":"help_functions.html#AbstractPlotting.help","page":"Help functions","title":"AbstractPlotting.help","text":"help(func[; extended = false])\n\nWelcome to the main help function of Makie.jl / AbstractPlotting.jl.\n\nFor help on a specific function's arguments, type help_arguments(function_name).\n\nFor help on a specific function's attributes, type help_attributes(plot_Type).\n\nUse the optional extended = true keyword argument to see more details.\n\n\n\n\n\n","category":"function"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"Example usage:","category":"page"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"using Makie # hide\nhelp(scatter; extended = true)","category":"page"},{"location":"help_functions.html#help_arguments-1","page":"Help functions","title":"help_arguments","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"help_arguments","category":"page"},{"location":"help_functions.html#AbstractPlotting.help_arguments","page":"Help functions","title":"AbstractPlotting.help_arguments","text":"help_arguments([io], func)\n\nReturns a list of signatures for function func.\n\n\n\n\n\n","category":"function"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"Example usage:","category":"page"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"using Makie # hide\nhelp_arguments(stdout, scatter)","category":"page"},{"location":"help_functions.html#help_attributes-1","page":"Help functions","title":"help_attributes","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"help_attributes","category":"page"},{"location":"help_functions.html#AbstractPlotting.help_attributes","page":"Help functions","title":"AbstractPlotting.help_attributes","text":"help_attributes([io], Union{PlotType, PlotFunction}; extended = false)\n\nReturns a list of attributes for the plot type Typ. The attributes returned extend those attributes found in the default_theme.\n\nUse the optional keyword argument extended (default = false) to show in addition the default values of each attribute. usage:\n\n>help_attributes(scatter)\n\talpha\n\tcolor\n\tcolormap\n\tcolorrange\n\tdistancefield\n\tglowcolor\n\tglowwidth\n\tlinewidth\n\tmarker\n\tmarker_offset\n\tmarkersize\n\toverdraw\n\trotations\n\tstrokecolor\n\tstrokewidth\n\ttransform_marker\n\ttransparency\n\tuv_offset_width\n\tvisible\n\n\n\n\n\n","category":"function"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"Example usage:","category":"page"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"using Makie # hide\nhelp_attributes(stdout, Scatter; extended = true)","category":"page"},{"location":"help_functions.html#Plot-styling-options-1","page":"Help functions","title":"Plot styling options","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"Use these functions to find out the styling options.","category":"page"},{"location":"help_functions.html#available_marker_symbols-1","page":"Help functions","title":"available_marker_symbols","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"using AbstractPlotting # hide\nAbstractPlotting.available_marker_symbols()","category":"page"},{"location":"help_functions.html#available_gradients-1","page":"Help functions","title":"available_gradients","text":"","category":"section"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"using AbstractPlotting # hide\nAbstractPlotting.available_gradients()","category":"page"},{"location":"help_functions.html#","page":"Help functions","title":"Help functions","text":"For other plot attributes and their usage, see the section Plot attributes.","category":"page"},{"location":"backends.html#Backends-1","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"There are three main backends for AbstractPlotting:","category":"page"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"GLMakie (Desktop, high performance, 100% features) default\nWGLMakie (Web, fast drawing, 80% features) Experimental\nCairoMakie (Print, SVG/PDF, 70% features) 2D-only (for now)","category":"page"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"You can activate any backend by using the appropriate package and calling it's activate! function; to activate WGLMakie, you would do susing WGLMakie; WGLMakie.activate!().","category":"page"},{"location":"backends.html#GLMakie-1","page":"Backends","title":"GLMakie","text":"","category":"section"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"GLMakie is the native, desktop-based backend, and is the most feature-complete.   It requires an OpenGL enabled graphics card with OpenGL version 3.3 or higher.","category":"page"},{"location":"backends.html#WGLMakie-1","page":"Backends","title":"WGLMakie","text":"","category":"section"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"WGLMakie is the Web-based backend, and is still experimental (though relatively feature-complete). Currently, installing it is not straightforward; see the WGLMakie.jl README for detailed instructions.","category":"page"},{"location":"backends.html#CairoMakie-1","page":"Backends","title":"CairoMakie","text":"","category":"section"},{"location":"backends.html#","page":"Backends","title":"Backends","text":"CairoMakie uses Cairo to draw vector graphics to SVG and PDF.   It needs Cairo.jl to build properly, which may be difficult on MacOS.","category":"page"},{"location":"devdocs.html#Devdocs-1","page":"Devdocs","title":"Devdocs","text":"","category":"section"},{"location":"devdocs.html#Logistical-issues-1","page":"Devdocs","title":"Logistical issues","text":"","category":"section"},{"location":"devdocs.html#Precompilation-1","page":"Devdocs","title":"Precompilation","text":"","category":"section"},{"location":"devdocs.html#","page":"Devdocs","title":"Devdocs","text":"Makie goes with the design of backends overloading the functions like scatter(::Backend, args...), which means they can be loaded in by Julia's normal code loading mechanisms, and should be precompile-safe. Makie also tries to be statically compilable, but this isn't as straightforward as one could think. So far it seems that all kind of globals are not save for static compilation and generated functions seem to also make problems. I'm slowly removing problematic constructs from the dependencies and try to get static compilation as quick as possible.","category":"page"},{"location":"devdocs.html#","page":"Devdocs","title":"Devdocs","text":"note: The state of static compilability in Makie\nCurrently, Makie is statically compilable.","category":"page"},{"location":"devdocs.html#TODOs-/-Up-for-grabs-1","page":"Devdocs","title":"TODOs / Up for grabs","text":"","category":"section"},{"location":"devdocs.html#","page":"Devdocs","title":"Devdocs","text":"Check out https://github.com/JuliaPlots/projects/1 for planned features and additions to Makie, as well as backlogged documentation issues.","category":"page"},{"location":"devdocs.html#Cameras-1","page":"Devdocs","title":"Cameras","text":"","category":"section"},{"location":"devdocs.html#","page":"Devdocs","title":"Devdocs","text":"If you're planning to add a new camera type, you will also have to edit the apply_camera! function, to accept your camera type.","category":"page"},{"location":"plot-attributes.html#Plot-attributes-1","page":"Plot attributes","title":"Plot attributes","text":"","category":"section"},{"location":"plot-attributes.html#","page":"Plot attributes","title":"Plot attributes","text":"using Makie","category":"page"},{"location":"plot-attributes.html#","page":"Plot attributes","title":"Plot attributes","text":"Below is a list of some common plot attributes for Makie.","category":"page"},{"location":"plot-attributes.html#","page":"Plot attributes","title":"Plot attributes","text":"To view a plot's attributes and their values, you can call plot.attributes to view the raw output, or plot.attributes.attributes to get a Dict of the attribute keys and their values.","category":"page"},{"location":"plot-attributes.html#","page":"Plot attributes","title":"Plot attributes","text":"p = scatter(rand(10), rand(10))[end]; # use `[end]` to access the plot\np.attributes\np.attributes.attributes","category":"page"},{"location":"plot-attributes.html#List-of-attributes-1","page":"Plot attributes","title":"List of attributes","text":"","category":"section"},{"location":"plot-attributes.html#","page":"Plot attributes","title":"Plot attributes","text":"Symbol Description\nabsorption Float32. Sets the absorption value for volume plots.\nalgorithm Algorithm to be used for volume plots. Can be one of :iso, :absorption, :mip, :absorptionrgba, or :indexedabsorption.\nalign (:pos, :pos). Specify the text alignment, where :pos can be :left, :center, or :right.\nalpha Float in [0,1]. The alpha value (transparency).\ncolor Symbol or Colorant. The color of the main plot element (markers, lines, etc.). Can be a color symbol/string like :red, or a Colorant.  Can also be an array or matrix of 'z-values' that are converted into colors by the colormap automatically.\ncolormap The color map of the main plot. Call available_gradients() to see what gradients are available. Can also be used with any Vector{<: Colorant}, or e.g. [:red, :black], or ColorSchemes.jl colormaps (by colormap = ColorSchemes.<colorscheme name>.colors).\ncolorrange A tuple (min, max) where min and max specify the data range to be used for indexing the colormap. E.g. color = [-2, 4] with colorrange = (-2, 4) will map to the lowest and highest color value of the colormap.\nfillrange Bool. Toggles range filling in contour plots.\nfont String. Specifies the font, and can choose any font available on the system.\nglowcolor Color Type. Color of the marker glow (outside the border) in scatter plots.\nglowwidth Number. Width of the marker glow in scatter plots.\nimage The image to be plotted on the plot.\ninterpolate Bool. For heatmap and images. Toggles color interpolation between nearby pixels.\nisorange Float32. Sets the isorange for volume plots.\nisovalue Float32. Sets the isovalue for volume plots.\nlevels Integer. Number of levels for a contour-type plot.\nlinestyle Symbol. Style of the line (for line and linesegments plots). Available styles are :dash, :dot, :dashdot, and :dashdotdot. You can also supply an array describing the length of each gap/fill.\nlinewidth Number. Width of the line in line and linesegments plots.\nmarker Symbol, Shape, or AbstractVector.\nmarker_offset Array of GeometryTypes.Point's. Specifies the offset coordinates for the markers. See the Marker offset example.\nmarkersize Number or AbstractVector. Specifies size (radius pixels) of the markers.\nposition NTuple{2,Float}, (x, y). Specify the coordinates to position text at.\nrotation Float32. Specifies the rotation in radians.\nrotations AbstractVector{Float32}. Similar to :rotation, except it specifies the rotations for each element in the plot.\nshading Bool. Specifies if shading should be on or not (for meshes).\nstrokecolor Color Type. Color of the marker stroke (border).\nstrokewidth Number. Width of the marker stroke (in pixels).\ntextsize Integer. Font pointsize for text.\ntransformation (:plane, location). Transforms the :plane to the specified location. Possible :plane's are :xy, :yz, and :xz.\nvisible Bool. Toggle visibility of plot.","category":"page"},{"location":"cameras.html#Cameras-1","page":"Cameras","title":"Cameras","text":"","category":"section"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"A Camera is simply a viewport through which the Scene is visualized.  Makie offers 2D and 3D projections, and 2D plots can be projected in 3D!","category":"page"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"To specify the camera you want to use for your Scene, you can set the camera attribute.  Currently, we offer four types of camera:","category":"page"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"cam2d!\ncam3d!\ncampixel!\ncam3d_cad!","category":"page"},{"location":"cameras.html#AbstractPlotting.cam2d!","page":"Cameras","title":"AbstractPlotting.cam2d!","text":"cam2d!(scene::SceneLike, kwargs...)\n\nCreates a 2D camera for the given Scene.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#AbstractPlotting.cam3d!","page":"Cameras","title":"AbstractPlotting.cam3d!","text":"cam3d!(scene; kwargs...)\n\nAn alias to cam3d_turntable!. Creates a 3D camera for scene, which rotates around the plot's axis.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#AbstractPlotting.campixel!","page":"Cameras","title":"AbstractPlotting.campixel!","text":"campixel!(scene)\n\nCreates a pixel-level camera for the Scene.  No controls!\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#AbstractPlotting.cam3d_cad!","page":"Cameras","title":"AbstractPlotting.cam3d_cad!","text":"cam3d_cad!(scene; kw_args...)\n\nCreates a 3D camera for scene which rotates around the viewer's \"up\" axis - similarly to how it's done in CAD software cameras.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"which will mutate the camera of the Scene into the specified type.","category":"page"},{"location":"cameras.html#Controlling-the-camera-1","page":"Cameras","title":"Controlling the camera","text":"","category":"section"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"We offer several functions to control the camera programatically.   You can rotate, translate, zoom and change the speed of the camera, as well as setting it to \"look at\" a certain point.","category":"page"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"translate_cam!\nrotate_cam!\nzoom!","category":"page"},{"location":"cameras.html#AbstractPlotting.translate_cam!","page":"Cameras","title":"AbstractPlotting.translate_cam!","text":"translate_cam!(scene::Scene. translation::VecTypes)\n\nTranslate the camera to the given coordinates.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#AbstractPlotting.rotate_cam!","page":"Cameras","title":"AbstractPlotting.rotate_cam!","text":"rotate_cam!(scene::Scene, theta_v::Number...)\nrotate_cam!(scene::Scene, theta_v::VecTypes)\n\nRotate the camera of the Scene by the given rotation.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#AbstractPlotting.zoom!","page":"Cameras","title":"AbstractPlotting.zoom!","text":"zoom!(scene, point, zoom_step)\n\nZooms the camera of scene in towards point by a factor of zoom_step.\n\n\n\n\n\n","category":"function"},{"location":"cameras.html#Updating-the-camera-1","page":"Cameras","title":"Updating the camera","text":"","category":"section"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"Often, when modifying the Scene, the camera can get \"out of sync\" with the Scene.  To fix this, you can call the update_cam! function on the Scene:","category":"page"},{"location":"cameras.html#","page":"Cameras","title":"Cameras","text":"update_cam!","category":"page"},{"location":"signatures.html#Plot-function-signatures-1","page":"Plot function signatures","title":"Plot function signatures","text":"","category":"section"},{"location":"signatures.html#General-function-signatures-and-usage-1","page":"Plot function signatures","title":"General function signatures and usage","text":"","category":"section"},{"location":"signatures.html#Create-a-new-plot-inside-a-new-scene-object-1","page":"Plot function signatures","title":"Create a new plot inside a new scene object","text":"","category":"section"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"func(args...; kw_args...)","category":"page"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"where func are the atomics function, e.g. lines, scatter, surface, etc. For a list of the available atomics functions, see Plotting functions overview.","category":"page"},{"location":"signatures.html#Create-a-new-plot-as-a-subscene-of-the-specified-scene-object-1","page":"Plot function signatures","title":"Create a new plot as a subscene of the specified scene object","text":"","category":"section"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"func(scene::SceneLike, args...; kw_args...)","category":"page"},{"location":"signatures.html#Add-a-plot-in-place-to-the-current_scene()-1","page":"Plot function signatures","title":"Add a plot in-place to the current_scene()","text":"","category":"section"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"func!(args...; kw_args...)","category":"page"},{"location":"signatures.html#Add-a-plot-in-place-to-the-specified-scene-as-a-subscene-1","page":"Plot function signatures","title":"Add a plot in-place to the specified scene as a subscene","text":"","category":"section"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"func!(scene::SceneLike, args...; kw_args...)","category":"page"},{"location":"signatures.html#Detailed-function-signatures-1","page":"Plot function signatures","title":"Detailed function signatures","text":"","category":"section"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"The input arguments are handled by the convert_arguments function, which handles a large variety of inputs. The signatures accepted by convert_arguments are also those accepted by the plotting functions.","category":"page"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"Accepted signatures are as follows:","category":"page"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"convert_arguments","category":"page"},{"location":"signatures.html#AbstractPlotting.convert_arguments","page":"Plot function signatures","title":"AbstractPlotting.convert_arguments","text":"Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y\n\n\n\n\n\nconvert_arguments(P, x, y, z)::(Vector)\n\nTakes vectors x, y, and z and turns it into a vector of 3D points of the values from x, y, and z. P is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x)::(Vector)\n\nTakes an input GeometryPrimitive x and decomposes it to points. P is the plot Type (it is optional).\n\n\n\n\n\nAccepts a Vector of Pair of Points (e.g. [Point(0, 0) => Point(1, 1), ...]) to encode e.g. linesegments or directions.\n\n\n\n\n\nconvert_arguments(P, y)::Vector\n\nTakes vector y and generates a range from 1 to the length of y, for plotting on an arbitrary x axis.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x, y)::(Vector)\n\nTakes vectors x and y and turns it into a vector of 2D points of the values from x and y.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}\n\nTakes 2 ClosedIntervals's x, y, and an AbstractMatrix z, and converts the closed range to linspaces with size(z, 1/2) P is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(x)::(String)\n\nTakes an input AbstractString x and converts it to a string.\n\n\n\n\n\nconvert_arguments(P, x)::(Vector)\n\nTakes an input HyperRectangle x and decomposes it to points.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)\n\nTakes 3 AbstractMatrix x, y, and z, converts them to Float32 and outputs them in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}\n\nTakes an AbstractMatrix, converts the dimesions n and m into ClosedInterval, and stores the ClosedInterval to n and m, plus the original matrix in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x, y, f)::(Vector, Vector, Matrix)\n\nTakes vectors x and y and the function f, and applies f on the grid that x and y span. This is equivalent to f.(x, y'). P is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}\n\nTakes an array of {T, 3} where T, converts the dimesions n, m and k into ClosedInterval, and stores the ClosedInterval to n, m and k, plus the original array in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)\n\nTakes 3 AbstractVector x, y, and z and the AbstractMatrix i, and puts everything in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)\n\nTakes AbstractVector x, y, and z and the function f, evaluates f on the volume spanned by x, y and z, and puts x, y, z and f(x,y,z) in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\nconvert_arguments(Mesh, x, y, z)::GLNormalMesh\n\nTakes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.\n\n\n\n\n\nconvert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh\n\nTakes an input mesh and a vector xyz representing the vertices of the mesh, and creates indices under the assumption, that each triplet in xyz forms a triangle.\n\n\n\n\n\nconvert_arguments(Mesh, x, y, z, indices)::GLNormalMesh\n\nTakes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in indices, which can be integers (every 3 -> one triangle), or GeometryTypes.Face{N, <: Integer}.\n\n\n\n\n\nconvert_arguments(Mesh, vertices, indices)::GLNormalMesh\n\nTakes vertices and indices, and creates a triangle mesh out of those. See to_vertices and to_triangles for more informations about accepted types.\n\n\n\n\n\n","category":"function"},{"location":"signatures.html#","page":"Plot function signatures","title":"Plot function signatures","text":"See Plot attributes for the available plot attributes.","category":"page"},{"location":"extending.html#Extending-1","page":"Extending","title":"Extending","text":"","category":"section"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"There are 4 ways to extend Makie:","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"By creating a new function combining multiple plotting commands (duh)\nBy overloading conversions for your custom type\nBy overloading plot(...) for your own type\nBy adding a new primitive + shader","category":"page"},{"location":"extending.html#Option-1-1","page":"Extending","title":"Option 1","text":"","category":"section"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"The first option is quite trivial and can be done in any plotting package and language: just create a function that scripts together a Plot.","category":"page"},{"location":"extending.html#Option-2-1","page":"Extending","title":"Option 2","text":"","category":"section"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"The plotting pipeline heavily relies on conversion functions which check the attributes for validity, document what's possible to pass and convert them to the types that the backends need. They usually look like this:","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"to_positions(backend, positions) = Point3f0.(positions) # E.g. everything that can be converted to a Point","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"As you can see, the first argument is the backend, so you can overload this for a specific backend or for a specific position type. This can look something like this:","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"@library[example] \"overload to position\"","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"since the pipeline for converting attributes also knows about Circle now, we can update the attribute directly with our own type","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"@library[example] \"change size\"","category":"page"},{"location":"extending.html#Option-3-1","page":"Extending","title":"Option 3","text":"","category":"section"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"Option 3 is very similar to Plots.jl recipes. Inside the function you can just use all of the plotting and drawing API to create a rich visual representation of your type. The signature that needs overloading is:","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"function plot(obj::MyType, kw_args::Dict)\n    # use primitives and other recipes to create a new plot\n    scatter(obj, kw_arg[:my_attribute])\n    lines(...)\n    polygon(...)\nend","category":"page"},{"location":"extending.html#Option-4-1","page":"Extending","title":"Option 4","text":"","category":"section"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"Option 4 is pretty unique and is a real extension of Makie's functionality as it adds a new primitive drawing type. This interface will likely change a lot in the future, since it carries quite a lot of technical debt from the design of GLAbstraction + GLVisualize, but this is how you can do it right now:","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"You will need to create defaults for the attributes of your new visual. For a documentation on how to use this macro look at Devdocs.","category":"page"},{"location":"extending.html#","page":"Extending","title":"Extending","text":"\nmy_attribute_convert(A::Array) = Texture(A)\nmy_attribute_convert(A::Texture) = A\nmy_attribute_convert(A) = error(\"A needs to be an array or Texture. Found: $(typeof(A))\")\n\n@default function my_drawing_type(scene, kw_args)\n    my_attribute = my_attribute_convert(my_attribute)\n    another_attribute = to_float(another_attribute) # always gets converted to Float32\nend\n\nfunction my_drawing_type(main_object::MyType, kw_args::Dict)\n    # optionally expand keyword arguments. E.g. m = (1, :white) becomes markersize = 1, markercolor = :white\n    kw_args = expand_kwargs(kw_args)\n    scene = get_global_scene()\n    # The default macro adds a _defaults to the function name\n    kw_args = my_drawing_type_defaults(scene, kw_args) # fill in and convert attributes\n\n    boundingbox = Node(AABB(Vec3f0(0), Vec3f0(1))) # calculate a boundingbox from your data\n\n    primitive = GL_TRIANGLES\n\n    vsh = vert\"\"\"\n        {{GLSL_VERSION}}\n        in vec2 position;\n        void main(){\n            gl_Position = vec4(position, 0, 1.0);\n        }\n    \"\"\"\n\n    fsh = frag\"\"\"\n        {{GLSL_VERSION}}\n        out vec4 outColor;\n        void main() {\n            outColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    \"\"\"\n    program = LazyShader(vsh, fsh)\n    robj = std_renderobject(shader_uniforms, program, boundingbox, primitive, nothing)\n    # The attributes that you add to the scene should be all signals and all editable.\n    # if an attribute is fixed, don't add it to the scene\n    insert_scene!(scene, :scatter, viz, attributes)\n    attributes\nend\n","category":"page"},{"location":"src-plot-attributes.html#","page":"-","title":"-","text":"using Makie","category":"page"},{"location":"src-plot-attributes.html#","page":"-","title":"-","text":"Below is a list of some common plot attributes for Makie.","category":"page"},{"location":"src-plot-attributes.html#","page":"-","title":"-","text":"To view a plot's attributes and their values, you can call plot.attributes to view the raw output, or plot.attributes.attributes to get a Dict of the attribute keys and their values.","category":"page"},{"location":"src-plot-attributes.html#","page":"-","title":"-","text":"p = scatter(rand(10), rand(10))[end]; # use `[end]` to access the plot\np.attributes\np.attributes.attributes","category":"page"},{"location":"abstractplotting_api.html#What's-exported-1","page":"AbstractPlotting Reference","title":"What's exported","text":"","category":"section"},{"location":"abstractplotting_api.html#","page":"AbstractPlotting Reference","title":"AbstractPlotting Reference","text":"Modules = [AbstractPlotting]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"abstractplotting_api.html#AbstractPlotting.Absolute","page":"AbstractPlotting Reference","title":"AbstractPlotting.Absolute","text":"Absolute\n\nForce transformation to be absolute, not relative to the current state. This is the default setting.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Accum","page":"AbstractPlotting Reference","title":"AbstractPlotting.Accum","text":"Accum\n\nForce transformation to be relative to the current state, not absolute.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Billboard","page":"AbstractPlotting Reference","title":"AbstractPlotting.Billboard","text":"Billboard attribute to always have a primitive face the camera. Can be used for rotation.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Camera","page":"AbstractPlotting Reference","title":"AbstractPlotting.Camera","text":"\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.FRect3D","page":"AbstractPlotting Reference","title":"AbstractPlotting.FRect3D","text":"An float valued, three dimensional rectangle.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect2D","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect2D","text":"An integer valued, two dimensional rectangle.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect3D","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect3D","text":"An integer valued, three dimensional rectangle.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.PlotList","page":"AbstractPlotting Reference","title":"AbstractPlotting.PlotList","text":"Plotlist(plots...)\n\nExperimental feature. Create an object that can encode multiple series.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.PlotSpec","page":"AbstractPlotting Reference","title":"AbstractPlotting.PlotSpec","text":"PlotSpec{P<:AbstractPlot}(args...; kwargs...)\n\nObject encoding positional arguments (args), a NamedTuple of attributes (kwargs) as well as plot type P of a basic plot.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Rect3D","page":"AbstractPlotting Reference","title":"AbstractPlotting.Rect3D","text":"A generic, three dimensional rectangle.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Reverse","page":"AbstractPlotting Reference","title":"AbstractPlotting.Reverse","text":"Reverses the attribute T upon conversion\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Scene","page":"AbstractPlotting Reference","title":"AbstractPlotting.Scene","text":"TODO document this\n\nFields\n\nparent\nevents\npx_area\ncamera\ncamera_controls\ndata_limits\ntransformation\nplots\ntheme\nattributes\nchildren\ncurrent_screens\nupdated\n\nConstructors\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Scene-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.Scene","text":"Scene(scene::Scene; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.Stepper","page":"AbstractPlotting Reference","title":"AbstractPlotting.Stepper","text":"Stepper for generating progressive plot examples.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Transformation","page":"AbstractPlotting Reference","title":"AbstractPlotting.Transformation","text":"Holds the transformations for Scenes.\n\nFields\n\nparent::Base.RefValue{AbstractPlotting.Transformable}\ntranslation::Observables.Observable{Vec{3,Float32}}\nscale::Observables.Observable{Vec{3,Float32}}\nrotation::Observables.Observable{Quaternion{Float32}}\nmodel::Observables.Observable{StaticArrays.SArray{Tuple{4,4},Float32,2,16}}\nflip::Observables.Observable{Tuple{Bool,Bool,Bool}}\nalign::Observables.Observable{Vec{2,Float32}}\ndata_func::Observables.Observable{Any}\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.VideoStream-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.VideoStream","text":"VideoStream(scene::Scene, framerate = 24)\n\nReturns a stream and a buffer that you can use, which don't allocate for new frames. Use recordframe!(stream) to add new video frames to the stream, and save(path, stream) to save the video.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.FRect-NTuple{4,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.FRect","text":"FRect(x, y, w, h)\n\nCreates a two dimensional rectangle, at origin (x, y) and with width w and height h.  Formally defined as the Cartesian product of the intervals (x, y) and (w, h).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect-NTuple{4,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect","text":"IRect(x, y, w, h)\n\nCreates a two dimensional rectangle of integer dimensions, at origin (x, y) and with width w and height h\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect-Tuple{Any,Any,Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect","text":"IRect(x, y, wh::VecTypes)\n\nCreates a two dimensional rectangle of integer dimensions, with origin at (x, y), and with width and height as the respective components of vector wh\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect-Tuple{NamedTuple{(:x, :y),T} where T<:Tuple,NamedTuple{(:width, :height),T} where T<:Tuple}","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect","text":"IRect(xy::NamedTuple{(:x, :y)}, wh::NamedTuple{(:width, :height)})\n\nThis takes two named tuples and constructs an integer valued rectangle with them.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N,Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect","text":"IRect(xy::VecTypes, w, h)\n\nCreates a two dimensional rectangle of integer dimensions, with origin at vector xy, and with width w and height h\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.IRect-Tuple{Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N,Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.IRect","text":"IRect(xy::VecTypes, wh::VecTypes)\n\nCreates a two dimensional rectangle of integer dimensions, with origin at vector xy, and with width and height as the respective components of vector wh\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.annotations!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.annotations!","text":"`annotations(strings::Vector{String}, positions::Vector{Point})`\n\nPlots an array of texts at each position in positions.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.annotations!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.annotations-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.annotations","text":"`annotations(strings::Vector{String}, positions::Vector{Point})`\n\nPlots an array of texts at each position in positions.\n\nTheme\n\nAvailable attributes and their defaults for Annotations{...} are: \n\n  align           (:left, :bottom)\n  alpha           1.0\n  color           :black\n  font            \"Dejavu Sans\"\n  linewidth       1\n  overdraw        false\n  position        Float32[0.0, 0.0]\n  rotation        0.0\n  strokecolor     (:black, 0.0)\n  strokewidth     0\n  textsize        20\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.arc!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.arc!","text":"arc(origin, radius, start_angle, stop_angle; kwargs...)\n\nThis function plots a circular arc, centered at origin with radius radius, from start_angle to stop_angle. origin must be a coordinate in 2 dimensions (i.e., a Point2); the rest of the arguments must be <: Number.\n\nExamples:\n\narc(Point2f0(0), 1, 0.0, π) arc(Point2f0(1, 2), 0.3. π, -π)\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.arc!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.arc-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.arc","text":"arc(origin, radius, start_angle, stop_angle; kwargs...)\n\nThis function plots a circular arc, centered at origin with radius radius, from start_angle to stop_angle. origin must be a coordinate in 2 dimensions (i.e., a Point2); the rest of the arguments must be <: Number.\n\nExamples:\n\narc(Point2f0(0), 1, 0.0, π) arc(Point2f0(1, 2), 0.3. π, -π)\n\nTheme\n\nAvailable attributes and their defaults for Arc{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  resolution      361\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.arrows!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.arrows!","text":"`arrows(points, directions; kwargs...)`\n`arrows(x, y, u, v)`\n`arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)`\n`arrows(x, y, z, u, v, w)`\n\nPlots arrows at the specified points with the specified components. u and v are interpreted as vector components (u being the x and v being the y), and the vectors are plotted with the tails at x, y.\n\nIf x, y, u, v are <: AbstractVector, then each 'row' is plotted as a single vector.\n\nIf u, v are <: AbstractMatrix, then x and y are interpreted as specifications for a grid, and u, v are plotted as arrows along the grid.\n\narrows can also work in three dimensions.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.arrows!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.arrows-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.arrows","text":"`arrows(points, directions; kwargs...)`\n`arrows(x, y, u, v)`\n`arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)`\n`arrows(x, y, z, u, v, w)`\n\nPlots arrows at the specified points with the specified components. u and v are interpreted as vector components (u being the x and v being the y), and the vectors are plotted with the tails at x, y.\n\nIf x, y, u, v are <: AbstractVector, then each 'row' is plotted as a single vector.\n\nIf u, v are <: AbstractMatrix, then x and y are interpreted as specifications for a grid, and u, v are plotted as arrows along the grid.\n\narrows can also work in three dimensions.\n\nTheme\n\nAvailable attributes and their defaults for Arrows{...} are: \n\n  arrowcolor   :black\n  arrowhead    AbstractPlotting.Automatic()\n  arrowsize    0.3\n  arrowtail    \"nothing\"\n  lengthscale  1.0f0\n  linecolor    :black\n  linestyle    \"nothing\"\n  linewidth    1\n  normalize    false\n  scale        Float32[1.0, 1.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.axis2d!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.axis2d!","text":"axis2d!(args; attributes...)\n\n\nPlots a 2-dimensional axis.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.axis2d!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.axis2d-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.axis2d","text":"axis2d(args; attributes...)\n\n\nPlots a 2-dimensional axis.\n\nTheme\n\nAxis attributes and their defaults for Axis2D{...} are: \n\n    showgrid: true\n    padding: 0.1\n    grid: \n        linestyle: (nothing, nothing)\n        linewidth: (0.5, 0.5)\n        linecolor: ((:black, 0.3), (:black, 0.3))\n    visible: true\n    ticks: \n        linecolor: ((:black, 0.4), (:black, 0.4))\n        linestyle: (nothing, nothing)\n        font: (\"Dejavu Sans\", \"Dejavu Sans\")\n        formatter: AbstractPlotting.Formatters.plain\n        align: ((:center, :top), (:right, :center))\n        textsize: (5, 5)\n        rotation: (0.0, 0.0)\n        textcolor: (:black, :black)\n        gap: 3\n        title_gap: 3\n        ranges_labels: (AbstractPlotting.Automatic(), AbstractPlotting.Automatic())\n        linewidth: (1, 1)\n    frame: \n        axis_position: nothing\n        linestyle: nothing\n        linewidth: 1.0\n        arrow_size: 2.5\n        axis_arrow: false\n        linecolor: black\n        frames: ((false, false), (false, false))\n    names: \n        axisnames: (\"x\", \"y\")\n        rotation: (0.0, -4.71238898038469)\n        font: (\"Dejavu Sans\", \"Dejavu Sans\")\n        title: nothing\n        textcolor: (:black, :black)\n        align: ((:center, :top), (:center, :bottom))\n        textsize: (6, 6)\n    showticks: true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.axis3d!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.axis3d!","text":"axis3d!(args; attributes...)\n\n\nPlots a 3-dimensional Axis.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.axis3d!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.axis3d-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.axis3d","text":"axis3d(args; attributes...)\n\n\nPlots a 3-dimensional Axis.\n\nTheme\n\nAxis attributes and their defaults for Axis3D{...} are: \n\n    showaxis: (true, true, true)\n    showgrid: (true, true, true)\n    padding: 0.1\n    visible: true\n    ticks: \n        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)\n        font: (\"Dejavu Sans\", \"Dejavu Sans\", \"Dejavu Sans\")\n        ranges_labels: (AbstractPlotting.Automatic(), AbstractPlotting.Automatic())\n        formatter: AbstractPlotting.Formatters.plain\n        textcolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0))\n        align: ((:left, :center), (:right, :center), (:right, :center))\n        textsize: (5, 5, 5)\n        gap: 1\n    frame: \n        axiscolor: (:black, :black, :black)\n        linewidth: (1, 1, 1)\n        linecolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0))\n    names: \n        axisnames: (\"x\", \"y\", \"z\")\n        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)\n        font: (\"Dejavu Sans\", \"Dejavu Sans\", \"Dejavu Sans\")\n        textcolor: (:black, :black, :black)\n        align: ((:left, :center), (:right, :center), (:right, :center))\n        textsize: (6.0, 6.0, 6.0)\n        gap: 1\n    showticks: (true, true, true)\n    scale: Float32[1.0, 1.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.band!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.band!","text":"band(x, ylower, yupper; kwargs...)\n\nPlots a band from ylower to yupper along x.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.band!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.band-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.band","text":"band(x, ylower, yupper; kwargs...)\n\nPlots a band from ylower to yupper along x.\n\nTheme\n\nAvailable attributes and their defaults for Band{...} are: \n\n  alpha           1.0\n  color           RGBA{Float32}(1.0f0,0.0f0,0.0f0,0.2f0)\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.barplot!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.barplot!","text":"barplot(x, y; kwargs...)\n\nPlots a barplot; y defines the height.  x and y should be 1 dimensional.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.barplot!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.barplot-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.barplot","text":"barplot(x, y; kwargs...)\n\nPlots a barplot; y defines the height.  x and y should be 1 dimensional.\n\nTheme\n\nAvailable attributes and their defaults for BarPlot{...} are: \n\n  color        :black\n  colormap     :viridis\n  colorrange   AbstractPlotting.Automatic()\n  fillto       0.0\n  marker       GeometryTypes.HyperRectangle\n  strokecolor  :white\n  strokewidth  0\n  width        AbstractPlotting.Automatic()\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.broadcast_foreach","text":"Like broadcast but for foreach. Doesn't care about shape and treats Tuples && StaticVectors as scalars.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.button!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.button!","text":"button(text)\n\nCreates a button which can be clicked. On click, the button increments its clicks field by one.\n\nFor example:\n\nscene = button(\"click me please\")\nlift(scene[end].clicks) do clicks\n    # your function here\nend\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.button!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.button-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.button","text":"button(text)\n\nCreates a button which can be clicked. On click, the button increments its clicks field by one.\n\nFor example:\n\nscene = button(\"click me please\")\nlift(scene[end].clicks) do clicks\n    # your function here\nend\n\nTheme\n\nAvailable attributes and their defaults for Button{...} are: \n\n  backgroundcolor  (:white, 0.4)\n  camera           AbstractPlotting.campixel!\n  clicks           0\n  dimensions       (40, 40)\n  padvalue         0.15\n  position         (10, 10)\n  raw              true\n  strokecolor      (:black, 0.4)\n  strokewidth      1\n  textcolor        :black\n  textsize         20\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.cam2d!-Tuple{Union{AbstractScene, ScenePlot}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.cam2d!","text":"cam2d!(scene::SceneLike, kwargs...)\n\nCreates a 2D camera for the given Scene.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.cam2d-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.cam2d","text":"Creates a subscene with a pixel camera\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.cam3d_cad!-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.cam3d_cad!","text":"cam3d_cad!(scene; kw_args...)\n\nCreates a 3D camera for scene which rotates around the viewer's \"up\" axis - similarly to how it's done in CAD software cameras.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.campixel!-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.campixel!","text":"campixel!(scene)\n\nCreates a pixel-level camera for the Scene.  No controls!\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.colorlegend!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.colorlegend!","text":"colorlegend(colormap, range)\ncolorlegend(plot::Plot)\n\nCreates a colorbar from the given colormap or range, or from the Attributes of the given Plot.\n\nTheme\n\nAvailable attributes and their defaults for ColorLegend{...} are:\n\nalign            (:left, :hcenter)   backgroundcolor  :white   camera           AbstractPlotting.campixel!   font             \"Dejavu Sans\"   formatter        AbstractPlotting.Formatters.plain   labels           AbstractPlotting.Automatic()   outerpadding     10   padding          10   position         (1, 1)   ranges           AbstractPlotting.Automatic()   raw              true   rotation         0.0   strokecolor      RGBA{Float64}(0.3,0.3,0.3,0.9)   strokewidth      0.3   textcolor        :black   textgap          15   textsize         16   width            (20, <the height of the scene> - 10)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.colorlegend-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.colorlegend","text":"colorlegend(colormap, range)\ncolorlegend(plot::Plot)\n\nCreates a colorbar from the given colormap or range, or from the Attributes of the given Plot.\n\nTheme\n\nAvailable attributes and their defaults for ColorLegend{...} are:\n\nalign            (:left, :hcenter)   backgroundcolor  :white   camera           AbstractPlotting.campixel!   font             \"Dejavu Sans\"   formatter        AbstractPlotting.Formatters.plain   labels           AbstractPlotting.Automatic()   outerpadding     10   padding          10   position         (1, 1)   ranges           AbstractPlotting.Automatic()   raw              true   rotation         0.0   strokecolor      RGBA{Float64}(0.3,0.3,0.3,0.9)   strokewidth      0.3   textcolor        :black   textgap          15   textsize         16   width            (20, <the height of the scene> - 10)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.contour!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.contour!","text":"contour(x, y, z)\n\nCreates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.contour!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.contour-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.contour","text":"contour(x, y, z)\n\nCreates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix\n\nTheme\n\nAvailable attributes and their defaults for Contour{...} are: \n\n  alpha           1.0\n  color           \"nothing\"\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  fillrange       false\n  levels          5\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.contour3d!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.contour3d!","text":"contour3d(x, y, z)\n\nCreates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.contour3d!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.contour3d-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.contour3d","text":"contour3d(x, y, z)\n\nCreates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.\n\nTheme\n\nAvailable attributes and their defaults for Contour3d{...} are: \n\n  alpha           1.0\n  color           \"nothing\"\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  fillrange       false\n  levels          5\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y, z)::(Vector)\n\nTakes vectors x, y, and z and turns it into a vector of 3D points of the values from x, y, and z. P is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y)::(Vector)\n\nTakes vectors x and y and turns it into a vector of 2D points of the values from x and y.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T<:Number}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, y)::Vector\n\nTakes vector y and generates a range from 1 to the length of y, for plotting on an arbitrary x axis.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.GeometryPrimitive}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x)::(Vector)\n\nTakes an input GeometryPrimitive x and decomposes it to points. P is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryTypes.HyperRectangle{2,T} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x)::(Vector)\n\nTakes an input HyperRectangle x and decomposes it to points.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T,2} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}\n\nTakes an AbstractMatrix, converts the dimesions n and m into ClosedInterval, and stores the ClosedInterval to n and m, plus the original matrix in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}\n\nTakes 2 ClosedIntervals's x, y, and an AbstractMatrix z, and converts the closed range to linspaces with size(z, 1/2) P is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,2} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)\n\nTakes 3 AbstractMatrix x, y, and z, converts them to Float32 and outputs them in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)\n\nTakes AbstractVector x, y, and z and the function f, evaluates f on the volume spanned by x, y and z, and puts x, y, z and f(x,y,z) in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{Type{#s207} where #s207<:(Mesh{...}),AbstractArray,AbstractArray}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(Mesh, vertices, indices)::GLNormalMesh\n\nTakes vertices and indices, and creates a triangle mesh out of those. See to_vertices and to_triangles for more informations about accepted types.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{Type{#s207} where #s207<:(Mesh{...}),AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh\n\nTakes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in indices, which can be integers (every 3 -> one triangle), or GeometryTypes.Face{N, <: Integer}.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{Type{#s207} where #s207<:(Mesh{...}),AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number,AbstractArray{T,1} where T<:Number}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(Mesh, x, y, z)::GLNormalMesh\n\nTakes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{Type{#s207} where #s207<:(Mesh{...}),AbstractArray{T,1} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh\n\nTakes an input mesh and a vector xyz representing the vertices of the mesh, and creates indices under the assumption, that each triplet in xyz forms a triangle.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Tuple{Type{#s207} where #s207<:(Text{...}),AbstractString}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(x)::(String)\n\nTakes an input AbstractString x and converts it to a string.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{#s207} where #s207<:(LineSegments{...}),AbstractArray{E,1}}} where E<:Union{Pair{A,A}, Tuple{A,A}} where A<:Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"Accepts a Vector of Pair of Points (e.g. [Point(0, 0) => Point(1, 1), ...]) to encode e.g. linesegments or directions.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{SurfaceLike,AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)\n\nTakes vectors x and y and the function f, and applies f on the grid that x and y span. This is equivalent to f.(x, y'). P is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)\n\nTakes 3 AbstractVector x, y, and z and the AbstractMatrix i, and puts everything in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{VolumeLike,AbstractArray{T,3}}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_arguments","text":"convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}\n\nTakes an array of {T, 3} where T, converts the dimesions n, m and k into ClosedInterval, and stores the ClosedInterval to n, m and k, plus the original array in a Tuple.\n\nP is the plot Type (it is optional).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"A Symbol/String naming the gradient. For more on what names are available please see: available_gradients(). For now, we support gradients from PlotUtils natively.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:colormap}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"to_colormap(b, x)\n\nAn AbstractVector{T} with any object that to_color accepts.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"`AbstractVector{<:AbstractFloat}` for denoting sequences of fill/nofill. e.g.\n\n[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"to_volume_algorithm(b, x)\n\nEnum values: IsoValue Absorption MaximumIntensityProjection AbsorptionRGBA IndexedAbsorptionRGBA\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"rotation accepts:\nto_rotation(b, quaternion)\nto_rotation(b, tuple_float)\nto_rotation(b, vec4)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Symbol,AbstractPlotting.Key{:linestyle}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"Text align, e.g.:\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"font conversion\n\na string naming a font, e.g. helvetica\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.convert_attribute-Tuple{Union{Tuple, Pair},AbstractPlotting.Key{:colormap}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.convert_attribute","text":"Tuple(A, B) or Pair{A, B} with any object that to_color accepts\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.fill_between!-Tuple{Any,Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.fill_between!","text":"fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)\n\nfill the section between 2 lines with the condition where\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.force_update!-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.force_update!","text":"Forces the scene to be re-rendered\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.hbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.hbox","text":"hbox(scenes...; parent = Scene(clear = false), kwargs...)\n\nAttach the given Scenes together on the horizontal axis.  For example, two Scenes hboxed will be placed one on top of the other.\n\n\n\n\n\n–    Scene 1     – –                – –––––––––– –––––––––– –                – –    Scene 2     – –                – ––––––––––\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.heatmap!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.heatmap!","text":"heatmap(x, y, values)\nheatmap(values)\n\nPlots a heatmap as an image on x, y (defaults to interpretation as dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.heatmap!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.heatmap-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.heatmap","text":"heatmap(x, y, values)\nheatmap(values)\n\nPlots a heatmap as an image on x, y (defaults to interpretation as dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Heatmap{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  levels          1\n  linewidth       0.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.help-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.help","text":"help(func[; extended = false])\n\nWelcome to the main help function of Makie.jl / AbstractPlotting.jl.\n\nFor help on a specific function's arguments, type help_arguments(function_name).\n\nFor help on a specific function's attributes, type help_attributes(plot_Type).\n\nUse the optional extended = true keyword argument to see more details.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.help_arguments-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.help_arguments","text":"help_arguments([io], func)\n\nReturns a list of signatures for function func.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.help_attributes-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.help_attributes","text":"help_attributes([io], Union{PlotType, PlotFunction}; extended = false)\n\nReturns a list of attributes for the plot type Typ. The attributes returned extend those attributes found in the default_theme.\n\nUse the optional keyword argument extended (default = false) to show in addition the default values of each attribute. usage:\n\n>help_attributes(scatter)\n\talpha\n\tcolor\n\tcolormap\n\tcolorrange\n\tdistancefield\n\tglowcolor\n\tglowwidth\n\tlinewidth\n\tmarker\n\tmarker_offset\n\tmarkersize\n\toverdraw\n\trotations\n\tstrokecolor\n\tstrokewidth\n\ttransform_marker\n\ttransparency\n\tuv_offset_width\n\tvisible\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.hovered_scene-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.hovered_scene","text":"hovered_scene()\n\nReturn the scene that the mouse is currently hovering over.\n\nProperly identifies the scene for a plot with multiple sub-plots.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.image!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.image!","text":"image(x, y, image)\nimage(image)\n\nPlots an image on range x, y (defaults to dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.image!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.image-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.image","text":"image(x, y, image)\nimage(image)\n\nPlots an image on range x, y (defaults to dimensions).\n\nTheme\n\nAvailable attributes and their defaults for Image{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        ColorTypes.RGBA{Float32}[RGBA{Float32}(0.0,0.0,0.0,1.0), RGBA{Float32}(1.0,1.0,1.0,1.0)]\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, ScenePlot},Union{Tuple, Array{T,1} where T}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.ispressed","text":"returns true if button is pressed in scene[:mousebuttons or :keyboardbuttons] You can use nothing, to indicate it should always return true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.legend!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.legend!","text":"`legend(plots, labels; kwargs...)`\n\nPlots a legend for the given plots with the given labels. plots may be a single Plot or a list of Plots.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.legend!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.legend-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.legend","text":"`legend(plots, labels; kwargs...)`\n\nPlots a legend for the given plots with the given labels. plots may be a single Plot or a list of Plots.\n\nTheme\n\nAvailable attributes and their defaults for Legend{...} are: \n\n  align            (:left, :center)\n  backgroundcolor  :white\n  camera           AbstractPlotting.campixel!\n  font             \"Dejavu Sans\"\n  gap              20\n  labelwidth       20\n  linepattern      Point{2,Float32}[[0.0, 0.0], [1.0, 0.0]]\n  markersize       5\n  outer_area       GeometryTypes.HyperRectangle{2,Int64}([0, 0], [1, 1])\n  outerpadding     10\n  padding          10\n  position         (1, 1)\n  raw              true\n  rotation         1.0 + 0.0im + 0.0jm + 0.0km\n  scatterpattern   Point{2,Float32}[[0.5, 0.0]]\n  strokecolor      RGBA{Float64}(0.3,0.3,0.3,0.9)\n  strokewidth      1\n  textcolor        :black\n  textgap          15\n  textsize         16\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.lines!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.lines!","text":"lines(positions)\nlines(x, y)\nlines(x, y, z)\n\nCreates a connected line plot for each element in (x, y, z), (x, y) or positions.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.lines!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.lines-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.lines","text":"lines(positions)\nlines(x, y)\nlines(x, y, z)\n\nCreates a connected line plot for each element in (x, y, z), (x, y) or positions.\n\nTheme\n\nAvailable attributes and their defaults for Lines{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.linesegments!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.linesegments!","text":"linesegments(positions)\nlinesegments(x, y)\nlinesegments(x, y, z)\n\nPlots a line for each pair of points in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.linesegments!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.linesegments-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.linesegments","text":"linesegments(positions)\nlinesegments(x, y)\nlinesegments(x, y, z)\n\nPlots a line for each pair of points in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for LineSegments{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.map_once-Tuple{Any,Observables.Observable,Vararg{Observables.Observable,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.map_once","text":"map_once(closure, inputs::Node....)::Node\n\nLike Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.\n\n``` function test(s1::Node)     s3 = maponce(x-> (println(\"1 \", x); x), s1)     s3 = maponce(x-> (println(\"2 \", x); x), s1)\n\nend test(Node(1), Node(2))\n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mesh!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.mesh!","text":"mesh(x, y, z)\nmesh(mesh_object)\nmesh(x, y, z, faces)\nmesh(xyz, faces)\n\nPlots a 3D mesh.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.mesh!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mesh-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.mesh","text":"mesh(x, y, z)\nmesh(mesh_object)\nmesh(x, y, z, faces)\nmesh(xyz, faces)\n\nPlots a 3D mesh.\n\nTheme\n\nAvailable attributes and their defaults for Mesh{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  interpolate     false\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.meshscatter!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.meshscatter!","text":"meshscatter(positions)\nmeshscatter(x, y)\nmeshscatter(x, y, z)\n\nPlots a mesh for each element in (x, y, z), (x, y), or positions (similar to scatter). markersize is a scaling applied to the primitive passed as marker.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.meshscatter!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.meshscatter-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.meshscatter","text":"meshscatter(positions)\nmeshscatter(x, y)\nmeshscatter(x, y, z)\n\nPlots a mesh for each element in (x, y, z), (x, y), or positions (similar to scatter). markersize is a scaling applied to the primitive passed as marker.\n\nTheme\n\nAvailable attributes and their defaults for MeshScatter{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  marker          GeometryTypes.HyperSphere{3,Float32}(Float32[0.0, 0.0, 0.0], 1.0f0)\n  markersize      0.1\n  overdraw        false\n  rotations       1.0 + 0.0im + 0.0jm + 0.0km\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mouse_selection-Tuple{Union{AbstractScene, ScenePlot}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.mouse_selection","text":"mouse_selection(scene::Scene)\n\nReturns the plot that is under the current mouse position\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mouseover-Tuple{Union{AbstractScene, ScenePlot},Vararg{AbstractPlot,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.mouseover","text":"mouseover(scene::SceneLike, plots::AbstractPlot...)\n\nReturns true if the mouse currently hovers any of plots.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mouseposition","page":"AbstractPlotting Reference","title":"AbstractPlotting.mouseposition","text":"mouseposition(scene = hovered_scene()) -> pos\n\nReturn the current position of the mouse pos in data points of the given scene.\n\nBy default uses the scene that the mouse is currently hovering over.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.move!-Tuple{Slider{...},Integer}","page":"AbstractPlotting Reference","title":"AbstractPlotting.move!","text":"move!(slider::Slider, idx::Integer)\n\nMoves the slider to the position of slider.range[idx].\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.must_update-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.must_update","text":"Returns whether a scene needs to be updated\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.onpick","page":"AbstractPlotting Reference","title":"AbstractPlotting.onpick","text":"onpick(func, plot)\n\nCalls func if one clicks on plot.  Implemented by the backend.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.onpick-Tuple{Any,Union{AbstractScene, ScenePlot},Vararg{AbstractPlot,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.onpick","text":"onpick(f, scene::SceneLike, plots::AbstractPlot...)\n\nCalls f(idx) whenever the mouse is over any of plots. idx is an index, e.g. when over a scatter plot, it will be the index of the hovered element\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.pick","page":"AbstractPlotting Reference","title":"AbstractPlotting.pick","text":"Picks a mouse position.  Implemented by the backend.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.pick-Tuple{Union{AbstractScene, ScenePlot},Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.pick","text":"pick(scene::Scene, xy::VecLike)\n\nReturn the plot under pixel position xy\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.pick-Tuple{Union{AbstractScene, ScenePlot},Number,Number}","page":"AbstractPlotting Reference","title":"AbstractPlotting.pick","text":"Return the plot under pixel position x y\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.plot!-Tuple{Union{AbstractScene, ScenePlot},Union{Type{Any}, Type{#s208} where #s208<:AbstractPlot},Attributes,Vararg{Any,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.plot!","text":"Main plotting signatures that plot/plot! route to if no Plot Type is given\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.poly!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.poly!","text":"`poly(vertices, indices; kwargs...)`\n`poly(points; kwargs...)`\n`poly(shape; kwargs...)`\n\nPlots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to mesh. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by GeometryTypes), it will plot decompose(shape).\n\npoly(coordinates, connectivity; kwargs...)\n\nPlots polygons, which are defined by coordinates (the coordinates of the vertices) and connectivity (the edges between the vertices).\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.poly!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.poly-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.poly","text":"`poly(vertices, indices; kwargs...)`\n`poly(points; kwargs...)`\n`poly(shape; kwargs...)`\n\nPlots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to mesh. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by GeometryTypes), it will plot decompose(shape).\n\npoly(coordinates, connectivity; kwargs...)\n\nPlots polygons, which are defined by coordinates (the coordinates of the vertices) and connectivity (the edges between the vertices).\n\nTheme\n\nAvailable attributes and their defaults for Poly{...} are: \n\n  color         :black\n  colormap      :viridis\n  colorrange    AbstractPlotting.Automatic()\n  linestyle     \"nothing\"\n  overdraw      false\n  shading       false\n  strokecolor   RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)\n  strokewidth   0.0\n  transparency  false\n  visible       true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.record-NTuple{4,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.record","text":"record(func, scene, path, iter; framerate = 24)\n\nThis is simply a shorthand to wrap a for loop in record.\n\nExample:\n\n    scene = lines(rand(10))\n    record(scene, \"test.gif\", 1:100) do i\n        scene.plots[:color] = Colors.RGB(i/255, 0, 0) # animate scene\n    end\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.record-Tuple{Any,Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.record","text":"record(func, scene, path; framerate = 24)\nrecord(func, scene, path, iter; framerate = 24)\n\nRecords the Scene scene after the application of func on it for each element in itr (any iterator).  func must accept an element of itr.\n\nThe animation is then saved to path, with the format determined by path's extension.  Allowable extensions are:\n\n.mkv  (the default, doesn't need to convert)\n.mp4  (good for Web, most supported format)\n.webm (smallest file size)\n.gif  (largest file size for the same quality)\n\n.mp4 and .mk4 are marginally bigger and .gifs are up to 6 times bigger with the same quality!\n\nTypical usage patterns would look like:\n\nrecord(scene, \"video.mp4\", itr) do i\n    func(i) # or some other manipulation of the Scene\nend\n\nor, for more tweakability,\n\nrecord(scene, \"test.gif\") do io\n    for i = 1:100\n        func!(scene)     # animate scene\n        recordframe!(io) # record a new frame\n    end\nend\n\nIf you want a more tweakable interface, consider using VideoStream and save.\n\nExamples\n\nscene = lines(rand(10))\nrecord(scene, \"test.gif\") do io\n    for i in 1:255\n        scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene\n        recordframe!(io)\n    end\nend\n\nor\n\nscene = lines(rand(10))\nrecord(scene, \"test.gif\", 1:255) do i\n    scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene\nend\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.record_events-Tuple{Any,Scene,String}","page":"AbstractPlotting Reference","title":"AbstractPlotting.record_events","text":"record_events(f, scene::Scene, path::String)\n\nRecords all window events that happen while executing function f for scene and serializes them to path.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.recordframe!-Tuple{VideoStream}","page":"AbstractPlotting Reference","title":"AbstractPlotting.recordframe!","text":"recordframe!(io::VideoStream)\n\nAdds a video frame to the VideoStream io.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.replace_automatic!","text":"Like get!(f, dict, key) but also calls f and replaces key when the corresponding value is nothing\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.replay_events-Tuple{Scene,String}","page":"AbstractPlotting Reference","title":"AbstractPlotting.replay_events","text":"replay_events(f, scene::Scene, path::String)\nreplay_events(scene::Scene, path::String)\n\nReplays the serialized events recorded with record_events in path in scene.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.rotate!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.rotate!","text":"rotate!(scene::Transformable, axis_rot::Quaternion)\nrotate!(scene::Transformable, axis_rot::AbstractFloat)\nrotate!(scene::Transformable, axis_rot...)\n\nApply an absolute rotation to the Scene.  Rotations are all internally converted to Quaternions.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.rotate!-Union{Tuple{T}, Tuple{Type{T},Transformable,Vararg{Any,N} where N}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.rotate!","text":"rotate!(Accum, scene::Transformable, axis_rot...)\n\nApply a relative rotation to the Scene, by multiplying by the current rotation.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.rotate_cam!-Tuple{Scene,Vararg{Number,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.rotate_cam!","text":"rotate_cam!(scene::Scene, theta_v::Number...)\nrotate_cam!(scene::Scene, theta_v::VecTypes)\n\nRotate the camera of the Scene by the given rotation.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.scale!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.scale!","text":"scale!(t::Transformable, x, y)\nscale!(t::Transformable, x, y, z)\nscale!(t::Transformable, xyz)\nscale!(t::Transformable, xyz...)\n\nScale the given Transformable (a Scene or Plot) to the given arguments. Can take x, y or x, y, z. This is an absolute scaling, and there is no option to perform relative scaling.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.scatter!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.scatter!","text":"scatter(positions)\nscatter(x, y)\nscatter(x, y, z)\n\nPlots a marker for each element in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.scatter!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.scatter-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.scatter","text":"scatter(positions)\nscatter(x, y)\nscatter(x, y, z)\n\nPlots a marker for each element in (x, y, z), (x, y), or positions.\n\nTheme\n\nAvailable attributes and their defaults for Scatter{...} are: \n\n  alpha             1.0\n  color             :black\n  colormap          :viridis\n  colorrange        AbstractPlotting.Automatic()\n  distancefield     \"nothing\"\n  glowcolor         RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  glowwidth         0.0\n  linewidth         1\n  marker            GeometryTypes.HyperSphere{2,T} where T\n  marker_offset     AbstractPlotting.Automatic()\n  markersize        0.1\n  overdraw          false\n  rotations         Billboard()\n  strokecolor       RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  strokewidth       0.0\n  transform_marker  false\n  transparency      false\n  uv_offset_width   Float32[0.0, 0.0, 0.0, 0.0]\n  visible           true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.scatterlines!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.scatterlines!","text":"scatterlines(xs, ys, [zs]; kwargs...)\n\nPlots lines between sets of x and y coordinates provided, as well as plotting those points using scatter.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.scatterlines!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.scatterlines-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.scatterlines","text":"scatterlines(xs, ys, [zs]; kwargs...)\n\nPlots lines between sets of x and y coordinates provided, as well as plotting those points using scatter.\n\nTheme\n\nAvailable attributes and their defaults for ScatterLines{...} are: \n\n  alpha             1.0\n  color             :black\n  colormap          :viridis\n  colorrange        AbstractPlotting.Automatic()\n  distancefield     \"nothing\"\n  glowcolor         RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  glowwidth         0.0\n  linestyle         \"nothing\"\n  linewidth         1\n  marker            GeometryTypes.HyperSphere{2,T} where T\n  marker_offset     AbstractPlotting.Automatic()\n  markersize        0.1\n  overdraw          false\n  rotations         Billboard()\n  strokecolor       RGBA{N0f8}(0.0,0.0,0.0,0.0)\n  strokewidth       0.0\n  transform_marker  false\n  transparency      false\n  uv_offset_width   Float32[0.0, 0.0, 0.0, 0.0]\n  visible           true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.select_rectangle-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.select_rectangle","text":"select_rectangle(scene; kwargs...) -> rect\n\nInteractively select a rectangle on a scene by clicking the left mouse button, dragging and then un-clicking. The function returns an observable rect whose value corresponds to the selected rectangle on the scene. In addition the function plots the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.\n\nThe value of the returned observable is updated only when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area > 0.\n\nThe kwargs... are propagated into lines! which plots the selected rectangle.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.series!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.series!","text":"Series - ?\n\nTODO add function signatures TODO add description\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.series!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.series-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.series","text":"Series - ?\n\nTODO add function signatures TODO add description\n\nTheme\n\nAvailable attributes and their defaults for Series{...} are: \n\n  seriescolors  :Set1\n  seriestype    :lines\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.showgradients-Tuple{AbstractArray{Symbol,1}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.showgradients","text":"showgradients(\n    cgrads::AbstractVector{Symbol};\n    h = 0.0, offset = 0.2, textsize = 0.7,\n    resolution = (800, length(cgrads) * 84)\n)::Scene\n\nPlots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.showlibrary-Tuple{Symbol}","page":"AbstractPlotting Reference","title":"AbstractPlotting.showlibrary","text":"showlibrary(lib::Symbol)::Scene\n\nShows all colour gradients in the given library. Returns a Scene with these colour gradients arranged as horizontal colourbars.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.slider!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.slider!","text":"slider(range; kwargs...)\n\nCreates a slider which slides through the selected range; sliders are discrete. The Slider's value can be accessed through its value field.  For example:\n\nscene = slider(1:10)\nlift(scene[end].value) do val\n    # your function here\nend\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.slider!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.slider-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.slider","text":"slider(range; kwargs...)\n\nCreates a slider which slides through the selected range; sliders are discrete. The Slider's value can be accessed through its value field.  For example:\n\nscene = slider(1:10)\nlift(scene[end].value) do val\n    # your function here\nend\n\nTheme\n\nAvailable attributes and their defaults for Slider{...} are: \n\n  backgroundcolor    (:gray, 0.01)\n  buttoncolor        :white\n  buttonsize         15\n  buttonstroke       1.5\n  buttonstrokecolor  :black\n  camera             AbstractPlotting.campixel!\n  position           (0, 0)\n  raw                true\n  slidercolor        (:gray, 0.6)\n  sliderheight       50\n  sliderlength       200\n  start              AbstractPlotting.Automatic()\n  strokecolor        (:black, 0.4)\n  strokewidth        1\n  textcolor          :black\n  textsize           15\n  value              0\n  valueprinter       AbstractPlotting.default_printer\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.spy!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.spy!","text":"spy(x::Range, y::Range, z::AbstractSparseArray)\n\nVisualizes big sparse matrices. Usage:\n\nN = 200_000\nx = sprand(Float64, N, N, (3(10^6)) / (N*N));\nspy(x)\n# or if you want to specify the range of x and y:\nspy(0..1, 0..1, x)\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.spy!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.spy-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.spy","text":"spy(x::Range, y::Range, z::AbstractSparseArray)\n\nVisualizes big sparse matrices. Usage:\n\nN = 200_000\nx = sprand(Float64, N, N, (3(10^6)) / (N*N));\nspy(x)\n# or if you want to specify the range of x and y:\nspy(0..1, 0..1, x)\n\nTheme\n\nAvailable attributes and their defaults for Spy{...} are: \n\n  colormap    :viridis\n  colorrange  AbstractPlotting.Automatic()\n  framecolor  :black\n  framesize   1\n  marker      AbstractPlotting.Automatic()\n  markersize  AbstractPlotting.Automatic()\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.step!-Tuple{Stepper}","page":"AbstractPlotting Reference","title":"AbstractPlotting.step!","text":"step!(s::Stepper)\n\nsteps through a Makie.Stepper and outputs a file with filename filename-step.jpg. This is useful for generating progressive plot examples.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.streamlines!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.streamlines!","text":"StreamLines\n\nTODO add function signatures TODO add descripton\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.streamlines!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.streamlines-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.streamlines","text":"StreamLines\n\nTODO add function signatures TODO add descripton\n\nTheme\n\nAvailable attributes and their defaults for StreamLines{...} are: \n\n  color      :black\n  h          0.01f0\n  linewidth  1\n  n          5\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.streamplot!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.streamplot!","text":"streamplot(f::function, xinterval, yinterval;\n    kwargs...)\n\nf must either accept f(::Point) or f(x::Number, y::Number). f must return a Point2. Example:\n\nusing MakieGallery, Makie\nrun_example(\"streamplot\")\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.streamplot!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.streamplot-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.streamplot","text":"streamplot(f::function, xinterval, yinterval;\n    kwargs...)\n\nf must either accept f(::Point) or f(x::Number, y::Number). f must return a Point2. Example:\n\nusing MakieGallery, Makie\nrun_example(\"streamplot\")\n\nTheme\n\nAvailable attributes and their defaults for StreamPlot{...} are: \n\n  arrow_size  0.03\n  colormap    :viridis\n  gridsize    (32, 32, 32)\n  stepsize    0.01\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.surface!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.surface!","text":"surface(x, y, z)\n\nPlots a surface, where (x, y)  define a grid whose heights are the entries in z.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.surface!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.surface-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.surface","text":"surface(x, y, z)\n\nPlots a surface, where (x, y)  define a grid whose heights are the entries in z.\n\nTheme\n\nAvailable attributes and their defaults for Surface{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linewidth       1\n  overdraw        false\n  shading         true\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.text!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.text!","text":"text(string)\n\nPlots a text.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.text!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.text-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.text","text":"text(string)\n\nPlots a text.\n\nTheme\n\nAvailable attributes and their defaults for Text{...} are: \n\n  align           (:left, :bottom)\n  alpha           1.0\n  color           :black\n  font            \"Dejavu Sans\"\n  linewidth       1\n  overdraw        false\n  position        Float32[0.0, 0.0]\n  rotation        0.0\n  strokecolor     (:black, 0.0)\n  strokewidth     0\n  textsize        20\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.timeseries!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.timeseries!","text":"timeseries(x::Node{{Union{Number, Point2}}})\n\nPlots a sampled signal. Usage:\n\nsignal = Node(1.0)\nscene = timeseries(signal)\ndisplay(scene)\n# @async is optional, but helps to continue evaluating more code\n@async while isopen(scene)\n    # aquire data from e.g. a sensor:\n    data = rand()\n    # update the signal\n    signal[] = data\n    # sleep/ wait for new data/ whatever...\n    # It's important to yield here though, otherwise nothing will be rendered\n    sleep(1/30)\nend\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.timeseries-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.timeseries","text":"timeseries(x::Node{{Union{Number, Point2}}})\n\nPlots a sampled signal. Usage:\n\nsignal = Node(1.0)\nscene = timeseries(signal)\ndisplay(scene)\n# @async is optional, but helps to continue evaluating more code\n@async while isopen(scene)\n    # aquire data from e.g. a sensor:\n    data = rand()\n    # update the signal\n    signal[] = data\n    # sleep/ wait for new data/ whatever...\n    # It's important to yield here though, otherwise nothing will be rendered\n    sleep(1/30)\nend\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.title-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.title","text":"title(\n    [scene=current_scene(), ], string;\n    align = (:center, :bottom), textsize = 30, kw...\n)\n\nAdd a title with content string to scene.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_color-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_color","text":"to_color(color)\n\nConverts a color symbol (e.g. :blue) to a color RGBA.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_colormap-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_colormap","text":"to_colormap(cm[, N = 20])\n\nConverts a colormap cm symbol (e.g. :Spectral) to a colormap RGB array, where N specifies the number of color points.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.translate!-Tuple{AbstractPlotting.Transformable,Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.translate!","text":"translate!(scene::Transformable, xyz::VecTypes)\ntranslate!(scene::Transformable, xyz...)\n\nApply an absolute translation to the Scene, translating it to x, y, z.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.translate!-Union{Tuple{T}, Tuple{Type{T},Transformable,Vararg{Any,N} where N}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.translate!","text":"translate!(Accum, scene::Transformable, xyz...)\n\nTranslate the scene relative to its current position.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.translate_cam!-Tuple{Scene,Union{Tuple{Vararg{T,N}}, StaticArray{Tuple{N},T,1}} where T where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.translate_cam!","text":"translate_cam!(scene::Scene. translation::VecTypes)\n\nTranslate the camera to the given coordinates.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.update!-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.update!","text":"`update!(p::Scene)`\n\nUpdates a Scene and all its children. Update will perform the following operations for every scene:\n\nif !scene.raw[]\n    scene.update_limits[] && update_limits!(scene)\n    scene.scale_plot[] && scale_scene!(scene)\n    scene.center[] && center!(scene)\nend\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.update_cam!","page":"AbstractPlotting Reference","title":"AbstractPlotting.update_cam!","text":"update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f0(0, 0, 1))\n\nUpdates the camera's controls to point to the specified location.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, ScenePlot},Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.update_cam!","text":"`update_cam!(scene::SceneLike, area)`\n\nUpdates the camera for the given scene to cover the given area in 2d.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, ScenePlot}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.update_cam!","text":"`update_cam!(scene::SceneLike)`\n\nUpdates the camera for the given scene to cover the limits of the Scene. Useful when using the Node pipeline.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.update_limits!","page":"AbstractPlotting Reference","title":"AbstractPlotting.update_limits!","text":"update_limits!(scene::Scene, new_limits::HyperRectangle, padding = Vec3f0(0))\n\nThis function updates the limits of the given Scene according to the given HyperRectangle.\n\nA HyperRectangle is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).\n\nSuch a HyperRectangle can be constructed using the FRect or FRect3D functions that are exported by AbstractPlotting.jl.  See their documentation for more information.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.update_limits!-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.update_limits!","text":"update_limits!(scene::Scene, limits::Union{Automatic, Rect} = scene.limits[], padding = scene.padding[])\n\nThis function updates the limits of the Scene passed to it based on its data. If an actual limit is set by the theme or its attributes (scene.limits !== automatic), it will not update the limits. Call update_limits!(scene, automatic) for that.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.vbox-Tuple{Vararg{AbstractPlotting.Transformable,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.vbox","text":"vbox(scenes...; parent = Scene(clear = false), kwargs...)\n\nBox the scenes together on the vertical axis.  For example, two Scenes vboxed will be placed side-by-side. ––––––––––  –––––––––– –                –  –                – –    Scene 1     –  –    Scene 2     – –                –  –                – ––––––––––  ––––––––––\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.volume!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.volume!","text":"volume(volume_data)\n\nPlots a volume. Available algorithms are:\n\n:iso => IsoValue\n:absorption => Absorption\n:mip => MaximumIntensityProjection\n:absorptionrgba => AbsorptionRGBA\n:indexedabsorption => IndexedAbsorptionRGBA\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.volume!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.volume-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.volume","text":"volume(volume_data)\n\nPlots a volume. Available algorithms are:\n\n:iso => IsoValue\n:absorption => Absorption\n:mip => MaximumIntensityProjection\n:absorptionrgba => AbsorptionRGBA\n:indexedabsorption => IndexedAbsorptionRGBA\n\nTheme\n\nAvailable attributes and their defaults for Volume{...} are: \n\n  absorption      1.0f0\n  algorithm       :iso\n  alpha           1.0\n  color           \"nothing\"\n  colormap        :viridis\n  colorrange      (0, 1)\n  isorange        0.05f0\n  isovalue        0.5f0\n  linewidth       1\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.volumeslices!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.volumeslices!","text":"VolumeSlices\n\nTODO add function signatures TODO add descripton\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.volumeslices!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.volumeslices-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.volumeslices","text":"VolumeSlices\n\nTODO add function signatures TODO add descripton\n\nTheme\n\nAvailable attributes and their defaults for VolumeSlices{...} are: \n\n  alpha       0.1\n  colormap    :viridis\n  colorrange  \"nothing\"\n  contour     Dict{Any,Any} with 0 entries\n  heatmap     Dict{Any,Any} with 0 entries\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.wireframe!-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.wireframe!","text":"`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`\n\nDraws a wireframe, either interpreted as a surface or as a mesh.\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.wireframe!,T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.wireframe-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.wireframe","text":"`wireframe(x, y, z)`, `wireframe(positions)`, or `wireframe(mesh)`\n\nDraws a wireframe, either interpreted as a surface or as a mesh.\n\nTheme\n\nAvailable attributes and their defaults for Wireframe{...} are: \n\n  alpha           1.0\n  color           :black\n  colormap        :viridis\n  colorrange      AbstractPlotting.Automatic()\n  linestyle       \"nothing\"\n  linewidth       1.0\n  overdraw        false\n  transparency    false\n  visible         true\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.xlabel!-Tuple{Any,AbstractString}","page":"AbstractPlotting Reference","title":"AbstractPlotting.xlabel!","text":"xlabel!([scene,] xlabel)\n\nSet the x-axis label for the given Scene. Defaults to using the current Scene.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.xlims!-Tuple{Scene,Tuple{Real,Real}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.xlims!","text":"xlims!(limits::Real...)\nxlims!(limits::NTuple{2, Real})\nxlims!(scene, limits::Real...)\nxlims!(scene, limits::NTuple{2, Real})\n\nSet the x-limits for the given Scene (defaults to current Scene).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.ylabel!-Tuple{Any,AbstractString}","page":"AbstractPlotting Reference","title":"AbstractPlotting.ylabel!","text":"ylabel!([scene,] ylabel)\n\nSet the y-axis label for the given Scene. Defaults to using the current Scene.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.ylims!-Tuple{Scene,Tuple{Real,Real}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.ylims!","text":"ylims!(limits::Real...)\nylims!(limits::NTuple{2, Real})\nylims!(scene, limits::Real...)\nylims!(scene, limits::NTuple{2, Real})\n\nSet the y-limits for the given Scene (defaults to current Scene).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.zlabel!-Tuple{Any,AbstractString}","page":"AbstractPlotting Reference","title":"AbstractPlotting.zlabel!","text":"zlabel!([scene,] zlabel)\n\nSet the z-axis label for the given Scene. Defaults to using the current Scene.\n\nwarning: Warning\nThe Scene must have an Axis3D.  If not, then this function will error.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.zlims!-Tuple{Scene,Tuple{Real,Real}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.zlims!","text":"zlims!(limits::Real...)\nzlims!(limits::NTuple{2, Real})\nzlims!(scene, limits::Real...)\nzlims!(scene, limits::NTuple{2, Real})\n\nSet the z-limits for the given Scene (defaults to current Scene).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.zoom!-Tuple{Any,Any,Any,Bool}","page":"AbstractPlotting Reference","title":"AbstractPlotting.zoom!","text":"zoom!(scene, point, zoom_step)\n\nZooms the camera of scene in towards point by a factor of zoom_step.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#FileIO.save-Tuple{String,VideoStream}","page":"AbstractPlotting Reference","title":"FileIO.save","text":"save(path::String, io::VideoStream; framerate = 24)\n\nFlushes the video stream and converts the file to the extension found in path, which can be one of the following:\n\n.mkv  (the default, doesn't need to convert)\n.mp4  (good for Web, most supported format)\n.webm (smallest file size)\n.gif  (largest file size for the same quality)\n\n.mp4 and .mk4 are marginally bigger and .gifs are up to 6 times bigger with the same quality!\n\nSee the docs of VideoStream for how to create a VideoStream. If you want a simpler interface, consider using record.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#FileIO.save-Union{Tuple{F}, Tuple{File{F},Scene}} where F","page":"AbstractPlotting Reference","title":"FileIO.save","text":"FileIO.save(filename, scene; resolution = size(scene))\n\nSaves a Scene to file! Allowable formats depend on the backend;\n\nGLMakie allows .png, .jpeg, and .bmp.\nCairoMakie allows .svg, pdf, and .jpeg.\nWGLMakie allows .png.\n\nResolution can be specified, via save(\"path\", scene, resolution = (1000, 1000))!\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#Observables.on-Tuple{Any,Camera,Vararg{Observables.Observable,N} where N}","page":"AbstractPlotting Reference","title":"Observables.on","text":"on(f, c::Camera, nodes::Node...)\n\nWhen mapping over nodes for the camera, we store them in the steering_node vector, to make it easier to disconnect the camera steering signals later!\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.@extract-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.@extract","text":"usage @exctract scene (a, b, c, d)\n\n\n\n\n\n","category":"macro"},{"location":"abstractplotting_api.html#AbstractPlotting.@extractvalue-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.@extractvalue","text":"usage @extractvalue scene (a, b, c, d) will become:\n\nbegin\n    a = to_value(scene[:a])\n    b = to_value(scene[:b])\n    c = to_value(scene[:c])\n    (a, b, c)\nend\n\n\n\n\n\n","category":"macro"},{"location":"abstractplotting_api.html#AbstractPlotting.@get_attribute-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.@get_attribute","text":"@get_attribute scene (a, b, c, d)\n\nThis will extract attribute a, b, c, d from scene and apply the correct attribute conversions + will extract the value if it's a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:\n\nbegin\n    a = get_attribute(scene, :a)\n    b = get_attribute(scene, :b)\n    c = get_attribute(scene, :c)\n    (a, b, c)\nend\n\n\n\n\n\n","category":"macro"},{"location":"abstractplotting_api.html#AbstractPlotting.@recipe-Tuple{Any,Symbol,Vararg{Symbol,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.@recipe","text":"Plot Recipes in AbstractPlotting\n\nThere's two types of recipes. Type recipes define a simple mapping from a user defined type to an existing plot type. Full recipes can customize the theme and define a custom plotting function.\n\nType recipes\n\nType recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:\n\n# All plot types\nconvert_arguments(P::Type{<:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))\n# Only for scatter plots\nconvert_arguments(P::Type{<:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))\n\nOptionally you may define the default plot type so that plot(x::MyType) will use this:\n\nplottype(::MyType) = Surface\n\nFull recipes with the @recipe macro\n\nA full recipe for MyPlot comes in two parts. First is the plot type name, arguments and theme definition which are defined using the @recipe macro. Second is a custom plot! for MyPlot, implemented in terms of the atomic plotting functions.\n\nWe use an example to show how this works:\n\n# arguments (x, y, z) && theme are optional\n@recipe(MyPlot, x, y, z) do scene\n    Theme(\n        plot_color => :red\n    )\nend\n\nThis macro expands to several things. Firstly a type definition:\n\nconst MyPlot{ArgTypes} = Combined{myplot, ArgTypes}\n\nThe type parameter of Combined contains the function instead of e.g. a symbol. This way the mapping from MyPlot to myplot is safer and simpler. (The downside is we always need a function myplot - TODO: is this a problem?)\n\nThe following signatures are defined to make MyPlot nice to use:\n\nmyplot(args...; kw_args...) = ...\nmyplot!(scene, args...; kw_args...) = ...\nmyplot(kw_args::Dict, args...) = ...\nmyplot!(scene, kw_args::Dict, args...) = ...\n#etc (not 100% settled what signatures there will be)\n\nA specialization of argument_names is emitted if you have an argument list (x,y,z) provided to the recipe macro:\n\nargument_names(::Type{<: MyPlot}) = (:x, :y, :z)\n\nThis is optional but it will allow the use of plot_object[:x] to fetch the first argument from the call plot_object = myplot(rand(10), rand(10), rand(10)), for example. Alternatively you can always fetch the ith argument using plot_object[i], and if you leave out the (x,y,z), the default version of argument_names will provide plot_object[:arg1] etc.\n\nThe theme given in the body of the @recipe invocation is inserted into a specialization of default_theme which inserts the theme into any scene that plots MyPlot:\n\nfunction default_theme(scene, ::MyPlot)\n    Theme(\n        plot_color => :red\n    )\nend\n\nAs the second part of defining MyPlot, you should implement the actual plotting of the MyPlot object by specializing plot!:\n\nfunction plot!(plot::MyPlot)\n    # normal plotting code, building on any previously defined recipes\n    # or atomic plotting operations, and adding to the combined `plot`:\n    lines!(plot, rand(10), color = plot[:plot_color])\n    plot!(plot, plot[:x], plot[:y])\n    plot\nend\n\nIt's possible to add specializations here, depending on the argument types supplied to myplot. For example, to specialize the behavior of myplot(a) when a is a 3D array of floating point numbers:\n\nconst MyVolume = MyPlot{Tuple{<:AbstractArray{<: AbstractFloat, 3}}}\nargument_names(::Type{<: MyVolume}) = (:volume,) # again, optional\nfunction plot!(plot::MyVolume)\n    # plot a volume with a colormap going from fully transparent to plot_color\n    volume!(plot, plot[:volume], colormap = :transparent => plot[:plot_color])\n    plot\nend\n\nThe docstring given to the recipe will be transferred to the functions it generates.\n\n\n\n\n\n","category":"macro"},{"location":"abstractplotting_api.html#What-isn't-1","page":"AbstractPlotting Reference","title":"What isn't","text":"","category":"section"},{"location":"abstractplotting_api.html#","page":"AbstractPlotting Reference","title":"AbstractPlotting Reference","text":"Modules = [AbstractPlotting]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"abstractplotting_api.html#AbstractPlotting.automatic","page":"AbstractPlotting Reference","title":"AbstractPlotting.automatic","text":"Singleton instance to indicate that an attribute will get calculated automatically\n\n\n\n\n\n","category":"constant"},{"location":"abstractplotting_api.html#AbstractPlotting.available_backends","page":"AbstractPlotting Reference","title":"AbstractPlotting.available_backends","text":"Currently available displays by backend\n\n\n\n\n\n","category":"constant"},{"location":"abstractplotting_api.html#AbstractPlotting.Automatic","page":"AbstractPlotting Reference","title":"AbstractPlotting.Automatic","text":"Type to indicate that an attribute will get calculated automatically\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.ColorSampler","page":"AbstractPlotting Reference","title":"AbstractPlotting.ColorSampler","text":"A colorsampler maps numnber values from a certain range to values of a colormap\n\nx = ColorSampler(colormap, (0.0, 1.0))\nx[0.5] # returns color at half point of colormap\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Transformable","page":"AbstractPlotting Reference","title":"AbstractPlotting.Transformable","text":"abstract type Transformable\n\nThis is a bit of a weird name, but all scenes and plots are transformable, so that's what they all have in common. This might be better expressed as traits.\n\n\n\n\n\n","category":"type"},{"location":"abstractplotting_api.html#AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.Plot","text":"Returns the Combined type that represents the signature of args.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}","page":"AbstractPlotting Reference","title":"AbstractPlotting.apply_convert!","text":"apply for return type     (args...,)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S","page":"AbstractPlotting Reference","title":"AbstractPlotting.apply_convert!","text":"apply for return type PlotSpec\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.argument_names-Union{Tuple{P}, Tuple{P}} where P<:AbstractPlot","page":"AbstractPlotting Reference","title":"AbstractPlotting.argument_names","text":"Each argument can be named for a certain plot type P. Falls back to arg1, arg2, etc.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.atomic_limits-Union{Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where #s207<:Tuple{Arg1}}, Tuple{Arg1}} where Arg1","page":"AbstractPlotting Reference","title":"AbstractPlotting.atomic_limits","text":"Data limits calculate a minimal boundingbox from the data points in a plot. This doesn't include any transformations, markers etc.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.available_gradients-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.available_gradients","text":"available_gradients()\n\nPrints all available gradient names.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.available_marker_symbols-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.available_marker_symbols","text":"available_marker_symbols()\n\nDisplays all available marker symbols.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.calculated_attributes!-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.calculated_attributes!","text":"`calculated_attributes!(trait::Type{<: AbstractPlot}, plot)`\n\ntrait version of calculated_attributes\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.calculated_attributes!-Union{Tuple{T}, Tuple{T}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.calculated_attributes!","text":"`calculated_attributes!(plot::AbstractPlot)`\n\nFill in values that can only be calculated when we have all other attributes filled\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.cam3d_turntable!-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.cam3d_turntable!","text":"cam3d_turntable!(scene; kw_args...)\n\nCreates a 3D camera for scene, which rotates around the plot's axis.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.close2square-Tuple{Real}","page":"AbstractPlotting Reference","title":"AbstractPlotting.close2square","text":"Returns (N1, N2) with N1 x N2 == n. N2 might become 1\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.colorswatch","page":"AbstractPlotting Reference","title":"AbstractPlotting.colorswatch","text":"colorswatch(scene = Scene(camera = campixel!))\n\nTODO add function signatures TODO add description\n\nTheme\n\nAvailable attributes and their defaults for Combined{AbstractPlotting.colorswatch,T} where T are: \n\n\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.current_scene-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.current_scene","text":"Returns the current active scene (the last scene that got created)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.default_plot_signatures","text":" default_plot_signatures(funcname, funcname!, PlotType)\n\nCreates all the different overloads for funcname that need to be supported for the plotting frontend! Since we add all these signatures to different functions, we make it reusable with this function. The Core.@__doc__ macro transfers the docstring given to the Recipe into the functions.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.default_printer-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.default_printer","text":"default_printer(v)\n\nPrints v rounded to three digits.  Here, v can be of any type accepted by round, which includes Real, Complex and many others.  To use your own custom datatype it is sufficient to define Base.round(x::NewType, r::RoundingMode).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.detach!-Tuple{Combined}","page":"AbstractPlotting Reference","title":"AbstractPlotting.detach!","text":"Remove combined from the current parent, and add it to a new subscene of the parent scene. Returns the new parent.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.dont_touch-Union{Tuple{N}, Tuple{GeometryPrimitive{N,T} where T,GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.dont_touch","text":"dont_touch(\n    parent::GeometryPrimitive{N}, child::GeometryPrimitive{N},\n    pad::Vec{N}\n) where N\n\nMoves child so that it doesn't touch parent. Leaves a gap to parent defined by pad.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1","page":"AbstractPlotting Reference","title":"AbstractPlotting.elconvert","text":"Converts the elemen array type to T1 without making a copy if the element type matches\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.extract_scene_attributes!-Tuple{Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.extract_scene_attributes!","text":"extract_scene_attributes!(attributes)\n\nremoves all scene attributes from attributes and returns them in a new Attribute dict.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.fit_factor-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.fit_factor","text":"fit_factor(rect, lims::NTuple{N}) where N\n\nCalculates the scaling one needs to apply to lims to fit rect without changing aspect ratio. Returns float scaling and the full strech as given by fit_factor_stretch\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.fit_factor_stretch-Union{Tuple{N}, Tuple{Any,Tuple{Vararg{Any,N}}}} where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.fit_factor_stretch","text":"fit_factor_stretch(rect, lims::NTuple{N}) where N\n\nCalculates the stretch factor to fill rect in all dimension. Returns a stretch N dimensional fit factor.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.fit_ratio-Tuple{Any,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.fit_ratio","text":"fit_ratio(rect, lims)\n\nCalculates the ratio one needs to stretch lims in order to get the same aspect ratio\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.flatten_combined","page":"AbstractPlotting Reference","title":"AbstractPlotting.flatten_combined","text":"Flattens all the combined plots and returns a Vector of Atomic plots\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.from_dict","text":"from_dict(::Type{T}, dict)\n\nCreates the type T from the fields in dict. Automatically converts to the correct node types.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.frustum","text":"Create view frustum\n\nParameters\n----------\n    left : float\n     Left coordinate of the field of view.\n    right : float\n     Left coordinate of the field of view.\n    bottom : float\n     Bottom coordinate of the field of view.\n    top : float\n     Top coordinate of the field of view.\n    znear : float\n     Near coordinate of the field of view.\n    zfar : float\n     Far coordinate of the field of view.\n\nReturns\n-------\n    M : array\n     View frustum matrix (4x4).\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.getscreen-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.getscreen","text":"getscreen(scene::Scene)\n\nGets the current screen a scene is associated with. Returns nothing if not yet displayed on a screen.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}, Tuple{AbstractArray{T,N} where N,AbstractFloat,Any}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.interpolated_getindex","text":"interpolated_getindex(cmap::AbstractArray, value::AbstractFloat, norm = (0.0, 1.0))\n\nLike getindex, but accepts values between 0..1 and interpolates those to the full range. You can use norm, to change the range of 0..1 to whatever you want.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.lookat","text":"view = lookat(eyeposition, lookat, up) creates a view matrix with the eye located at eyeposition and looking at position lookat, with the top of the window corresponding to the direction up. Only the component of up that is perpendicular to the vector pointing from eyeposition to lookat will be used.  All inputs must be supplied as 3-vectors.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.mouse_in_scene-Tuple{Union{AbstractScene, ScenePlot}}","page":"AbstractPlotting Reference","title":"AbstractPlotting.mouse_in_scene","text":"mouse_in_scene(scene::Scene)\n\nreturns the mouseposition relative to scene\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.move_from_touch-Union{Tuple{T}, Tuple{N}, Tuple{GeometryPrimitive{N,T},GeometryPrimitive{N,T} where T,Vec{N,T} where T}} where T where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.move_from_touch","text":"move_from_touch(\n    parent::GeometryPrimitive{N, T}, child::GeometryPrimitive{N},\n    pad::Vec{N}\n) where {N, T}\n\ncalculates how much child rectangle needs to move to not touch the parent\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.notify!-Tuple{Observables.Observable}","page":"AbstractPlotting Reference","title":"AbstractPlotting.notify!","text":"Pushes an updates to all listeners of node\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.perspectiveprojection","text":"proj = perspectiveprojection([T], fovy, aspect, znear, zfar) defines a projection matrix with a given angular field-of-view fovy along the y-axis (measured in degrees), the specified aspect ratio, and near and far clipping planes znear, zfar. Optionally specify the element type T of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{SimpleRectangle,T,T,T}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.perspectiveprojection","text":"proj = perspectiveprojection([T], rect, fov, near, far) defines the projection ratio in terms of the rectangular view size rect rather than the aspect ratio.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.plots_from_camera-Tuple{Scene}","page":"AbstractPlotting Reference","title":"AbstractPlotting.plots_from_camera","text":"Fetches all plots sharing the same camera\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.plottype-Tuple","page":"AbstractPlotting Reference","title":"AbstractPlotting.plottype","text":"`plot_type(plot_args...)`\n\nThe default plot type for any argument is lines. Any custom argument combination that has only one meaningful way to be plotted should overload this. e.g.:\n\n    # make plot(rand(5, 5, 5)) plot as a volume\n    plottype(x::Array{<: AbstractFlot, 3}) = Volume\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{#s206} where #s206<:(Combined{Any,T} where T),Type{#s205} where #s205<:(Combined{T,T1} where T1)}} where T","page":"AbstractPlotting Reference","title":"AbstractPlotting.plottype","text":"plottype(P1::Type{<: Combined{T1}}, P2::Type{<: Combined{T2}})\n\nChooses the more concrete plot type ```example function convert_arguments(P::PlotFunc, args...)     ptype = plottype(P, Lines)     ... end\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.primary_resolution-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.primary_resolution","text":"Returns the resolution of the primary monitor. If the primary monitor can't be accessed, returns (1920, 1080) (full hd)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.print_rec","page":"AbstractPlotting Reference","title":"AbstractPlotting.print_rec","text":"print_rec(io::IO, dict, indent::Int = 1[; extended = false])\n\nTraverses a dictionary dict and recursively print out its keys and values in a nicely-indented format.\n\nUse the optional extended = true keyword argument to see more details.\n\n\n\n\n\n","category":"function"},{"location":"abstractplotting_api.html#AbstractPlotting.raw_boundingbox-Tuple{Union{Text{...}, MeshScatter{...}, Scatter{...}, Mesh{...}, LineSegments{...}, Lines{...}, Surface{...}, Volume{...}, Heatmap{...}, Image{...}} where Arg}","page":"AbstractPlotting Reference","title":"AbstractPlotting.raw_boundingbox","text":"Calculates the exact boundingbox of a Scene/Plot, without considering any transformation\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.reasonable_resolution-Tuple{}","page":"AbstractPlotting Reference","title":"AbstractPlotting.reasonable_resolution","text":"Returns a reasonable resolution for the main monitor. (right now just half the resolution of the main monitor)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}","page":"AbstractPlotting Reference","title":"AbstractPlotting.resample","text":"resample(A::AbstractVector, len::Integer)\n\nResample a vector with linear interpolation to have length len\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.resampled_colors-Tuple{Any,Integer}","page":"AbstractPlotting Reference","title":"AbstractPlotting.resampled_colors","text":"resampled_colors(attributes::Attributes, levels::Integer)\n\nResample the color attribute from attributes. Resamples :colormap if present, or repeats :color.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.safe_off","text":"Observables.off but without throwing an error\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.screen_relative-Tuple{Scene,Any}","page":"AbstractPlotting Reference","title":"AbstractPlotting.screen_relative","text":"Normalizes mouse position relative to the screen rectangle\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.sig_printer-Tuple{Real}","page":"AbstractPlotting Reference","title":"AbstractPlotting.sig_printer","text":"sig_printer(v::Real)\n\nPrints the first three significant digits of v in scientific notation.\n\njulia> -5:5 .|> exp .|> sig_printer\n11-element Array{String,1}:\n \"6.74e-03\"\n \"1.83e-02\"\n \"4.98e-02\"\n \"1.35e-01\"\n \"3.68e-01\"\n \"1.00e+00\"\n \"2.72e+00\"\n \"7.39e+00\"\n \"2.01e+01\"\n \"5.46e+01\"\n \"1.48e+02\"\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.streamplot_impl-Union{Tuple{T}, Tuple{N}, Tuple{Any,Any,HyperRectangle{N,T},Any,Any}} where T where N","page":"AbstractPlotting Reference","title":"AbstractPlotting.streamplot_impl","text":"Code adapted from an example implementation by Moritz Schauer (@mschauer) from https://github.com/JuliaPlots/Makie.jl/issues/355#issuecomment-504449775\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_func-Union{Tuple{Type{#s207} where #s207<:AbstractPlot{F}}, Tuple{F}} where F","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_func","text":"to_func(Typ)\n\nMaps the input of a Type name to its cooresponding function.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{#s207,2} where #s207<:ColorTypes.Colorant}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"Any AbstractMatrix{<: Colorant} or other image type\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"Vector of anything that is accepted as a single marker will give each point it's own marker. Note that it needs to be a uniform vector with the same element type!\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{Array{#s207,2} where #s207<:AbstractFloat}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"Matrix of AbstractFloat will be interpreted as a distancefield (negative numbers outside shape, positive inside)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{Char}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"to_spritemarker(b, marker::Char)\n\nAny Char, including unicode\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{GeometryTypes.HyperSphere{2,T} where T}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"to_spritemarker(b, x::Circle)\n\nGeometryTypes.Circle(Point2(...), radius)\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{Symbol}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"A Symbol - Available options can be printed with available_marker_symbols()\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{Type{#s207} where #s207<:(GeometryTypes.HyperSphere{2,T} where T)}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"to_spritemarker(b, ::Type{Circle})\n\nType{GeometryTypes.Circle}\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_spritemarker-Tuple{Type{#s207} where #s207<:GeometryTypes.SimpleRectangle}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_spritemarker","text":"to_spritemarker(b, ::Type{Rectangle})\n\nType{GeometryTypes.Rectangle}\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_string-Tuple{Function}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_string","text":"to_string(func)\n\nTurns the input of a function name or plot Type into a string.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.to_type-Tuple{Function}","page":"AbstractPlotting Reference","title":"AbstractPlotting.to_type","text":"to_type(func)\n\nMaps the input of a function name to its cooresponding Type.\n\n\n\n\n\n","category":"method"},{"location":"abstractplotting_api.html#AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}","page":"AbstractPlotting Reference","title":"AbstractPlotting.used_attributes","text":"used_attributes(args...) = ()\n\nfunction used to indicate what keyword args one wants to get passed in convert_arguments. Usage:\n\n    struct MyType end\n    used_attributes(::MyType) = (:attribute,)\n    function convert_arguments(x::MyType; attribute = 1)\n        ...\n    end\n    # attribute will get passed to convert_arguments\n    # without keyword_verload, this wouldn't happen\n    plot(MyType, attribute = 2)\n    #You can also use the convenience macro, to overload convert_arguments in one step:\n    @keywords convert_arguments(x::MyType; attribute = 1)\n        ...\n    end\n\n\n\n\n\n","category":"method"},{"location":"statsmakie.html#StatsMakie-Tutorial-1","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"This tutorial shows how to create data visualizations using the StatsMakie grouping and styling APIs as well as the StatsMakie statistical recipes.","category":"page"},{"location":"statsmakie.html#Grouping-data-by-discrete-variables-1","page":"StatsMakie Tutorial","title":"Grouping data by discrete variables","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"The first feature that StatsMakie adds to Makie is the ability to group data by some discrete variables and use those variables to style the result. Let's first create some vectors to play with:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 1)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"To see how x and y relate to each other, we could simply try (be warned: the first plot is quite slow, the following ones will be much faster):","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 2)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"It looks like there are two components in the data, and we can ask whether they come from different values of the a variable:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 3)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Group will split the data by the discrete variable we provided and color according to that variable. Colors will cycle across a range of default values, but we can easily customize those:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 4)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"and of course we are not limited to grouping with colors: we can use the shape of the marker instead. Group(a) defaults to Group(color = a), whereas Group(marker = a) with encode the information about variable a in the marker:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 5)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Grouping by many variables is also supported:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 6)","category":"page"},{"location":"statsmakie.html#Styling-data-with-continuous-variables-1","page":"StatsMakie Tutorial","title":"Styling data with continuous variables","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"One of the advantage of using an inherently discrete quantity (like the shape of the marker) to encode a discrete variable is that we can use continuous attributes (e.g. color within a colorscale) for continuous variable. In this case, if we want to see how a, x, y, z interact, we could choose the marker according to a and style the color according to z:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 7)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Just like with Group, we can Style any number of attributes in the same plot. color is probably the most common, markersize is another sensible option (especially if we are using color already for the grouping):","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 8)","category":"page"},{"location":"statsmakie.html#Split-apply-combine-strategy-with-a-plot-1","page":"StatsMakie Tutorial","title":"Split-apply-combine strategy with a plot","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"StatsMakie also has the concept of a \"visualization\" function (which is somewhat different but inspired on Grammar of Graphics statistics). The idea is that any function whose return type is understood by StatsMakie (meaning, there is an appropriate visualization for it) can be passed as first argument and it will be applied to the following arguments as well.","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"A simple example is probably linear and non-linear regression.","category":"page"},{"location":"statsmakie.html#Linear-regression-1","page":"StatsMakie Tutorial","title":"Linear regression","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"StatsMakie knows how to compute both a linear and non-linear fit of y as a function of x, via the \"analysis functions\" linear (linear regression) and smooth (local polynomial regression) respectively:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 9)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"That was anti-climatic! It is the linear prediction of y given x, but it's a bit of a sad plot! We can make it more colorful by splitting our data by a, and everything will work as above:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 10)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"And then we can plot it on top of the previous scatter plot, to make sure we got a good fit:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 11)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Here of course it makes sense to group both things by color, but for line plots we have other options like linestyle:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 12)","category":"page"},{"location":"statsmakie.html#A-non-linear-example-1","page":"StatsMakie Tutorial","title":"A non-linear example","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Using non-linear techniques here is not very interesting as linear techniques work quite well already, so let's change variables:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 12)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"and then:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 13)","category":"page"},{"location":"statsmakie.html#Different-analyses-1","page":"StatsMakie Tutorial","title":"Different analyses","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"linear and smooth are two examples of possible analysis, but many more are possibles and it's easy to add new ones. If we were interested to the distributions of x and y for example we could do:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 14)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"The default plot type is determined by the dimensionality of the input and the analysis. A histogram analysis over one input variable produces a bar plot:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 15)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"whereas with two variables one would get a heatmap:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 16)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"This plots is reasonably customizable in that one can pass keywords arguments to the histogram analysis:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 17)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"and change the default plot type to something else:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 18)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Of course heatmap is the saner choice, but why not abuse Makie 3D capabilities?","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Other available analysis are density (to use kernel density estimation rather than binning) and frequency (to count occurrences of discrete variables).","category":"page"},{"location":"statsmakie.html#What-if-my-data-is-in-a-table,-such-as-a-DataFrame?-1","page":"StatsMakie Tutorial","title":"What if my data is in a table, such as a DataFrame?","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"It is possible to signal StatsMakie that we are working from a DataFrame (or any table actually) and it will interpret symbols as columns:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 19)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"And everything else works as usual:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 20)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 21)","category":"page"},{"location":"statsmakie.html#Plotting-multiple-columns-1","page":"StatsMakie Tutorial","title":"Plotting multiple columns","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Other than comparing the same column split by a categorical variable, one may also compare different columns put side by side (here in a Tuple, (:PetalLength, :PetalWidth)). The attribute that styles them has to be set to bycolumn. Here color will distinguish :PetalLength versus :PetalWidth whereas the marker will distinguish the species.","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"StatsMakie\", 22)","category":"page"},{"location":"statsmakie.html#Analysis-of-data-1","page":"StatsMakie Tutorial","title":"Analysis of data","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"There are multiple options with which to analyze your data before plotting it.  These are:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"density (kernel density estimation, 1D or 2D)\nhistogram (1D, 2D or even 3D!)\nfrequency (count occurrences of discrete variables, 1 or 2D)\nlinear (linear regression)\nsmooth (LOESS regression)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"To use these analyses, one can simply write something like plot(density, x, y).  One can also pass options to the analysis, as in: plot(density(bandwidth=0.1), x, y), or something analogous for other analyses.","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"For example, see the initial setup below:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 1)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"for which one can plot a kernel density estimation:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 2)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"or a histogram:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 3)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"One can also count the frequency of a discrete variable:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 4)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"Fitting data using LOESS fitting is of course possible:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 5)","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"and, as seen earlier, fitting it with a line is possible as well.","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Analysis\", 6)","category":"page"},{"location":"statsmakie.html#Statistical-plot-types-1","page":"StatsMakie Tutorial","title":"Statistical plot types","text":"","category":"section"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"One can use box plots and violin plots with the same interface as StatsPlots.  ","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"One can create a box plot:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Box plot\")","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"or a violin plot:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Violin plot\")","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"and the two can be superimposed:","category":"page"},{"location":"statsmakie.html#","page":"StatsMakie Tutorial","title":"StatsMakie Tutorial","text":"@example_database(\"Violin and box plot\")","category":"page"},{"location":"animation.html#Animation-1","page":"Animation","title":"Animation","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"Makie.jl has extensive support for animations; you can create arbitrary plots, and save them to:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":".mkv  (the default, doesn't need to convert)\n.mp4  (good for Web, most supported format)\n.webm (smallest file size)\n.gif  (largest file size for the same quality)","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"This is all made possible through the use of the ffmpeg tool, wrapped by FFMPEG.jl.","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"Have a peek at Interaction for some more information once you're done with this.","category":"page"},{"location":"animation.html#A-simple-example-1","page":"Animation","title":"A simple example","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"Simple animations are easy to make; all you need to do is wrap your changes in the record function.","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"When recording, you can make changes to any aspect of the Scene or its plots.  ","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"Below is a small example of using record.","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"@example_database(\"Line changing colour\")","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"record","category":"page"},{"location":"animation.html#AbstractPlotting.record","page":"Animation","title":"AbstractPlotting.record","text":"record(func, scene, path; framerate = 24)\nrecord(func, scene, path, iter; framerate = 24)\n\nRecords the Scene scene after the application of func on it for each element in itr (any iterator).  func must accept an element of itr.\n\nThe animation is then saved to path, with the format determined by path's extension.  Allowable extensions are:\n\n.mkv  (the default, doesn't need to convert)\n.mp4  (good for Web, most supported format)\n.webm (smallest file size)\n.gif  (largest file size for the same quality)\n\n.mp4 and .mk4 are marginally bigger and .gifs are up to 6 times bigger with the same quality!\n\nTypical usage patterns would look like:\n\nrecord(scene, \"video.mp4\", itr) do i\n    func(i) # or some other manipulation of the Scene\nend\n\nor, for more tweakability,\n\nrecord(scene, \"test.gif\") do io\n    for i = 1:100\n        func!(scene)     # animate scene\n        recordframe!(io) # record a new frame\n    end\nend\n\nIf you want a more tweakable interface, consider using VideoStream and save.\n\nExamples\n\nscene = lines(rand(10))\nrecord(scene, \"test.gif\") do io\n    for i in 1:255\n        scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene\n        recordframe!(io)\n    end\nend\n\nor\n\nscene = lines(rand(10))\nrecord(scene, \"test.gif\", 1:255) do i\n    scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene\nend\n\n\n\n\n\nrecord(func, scene, path, iter; framerate = 24)\n\nThis is simply a shorthand to wrap a for loop in record.\n\nExample:\n\n    scene = lines(rand(10))\n    record(scene, \"test.gif\", 1:100) do i\n        scene.plots[:color] = Colors.RGB(i/255, 0, 0) # animate scene\n    end\n\n\n\n\n\n","category":"function"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"In both cases, the returned value is a path pointing to the location of the recorded file.","category":"page"},{"location":"animation.html#Animation-using-time-1","page":"Animation","title":"Animation using time","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"To animate a scene, you can also create a Node, e.g.:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"time = Node(0.0)","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"and use lift on the Node to set up a pipeline to access its value. For example:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"scene = Scene()\ntime = Node(0.1)\nmyfunc(v, t) = sin.(v .* t)\npositions = lift(t -> myfunc.(range(0, stop=2pi, length=50), t), time)\nscene = lines!(scene, positions)","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"now, whenever the Node time is updated (e.g. when you push! to it), the plot will also be updated.","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"push!(time, Base.time())","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"You can also set most attributes equal to Observables, so that you need only update a single variable (like time) during your animation loop.  A translation of the first example to this Observables paradigm is below:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"@example_database(\"Line changing colour with Observables\")","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"A more complicated example:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"@example_database(\"Record Video\")","category":"page"},{"location":"animation.html#Appending-data-to-a-plot-1","page":"Animation","title":"Appending data to a plot","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"If you're planning to append to a plot, like a lines or scatter plot (basically, anything that's point-based), you will want to pass an Observable Array of Points to the plotting function, instead of passing x, y (and z) as separate Arrays. This will mean that you won't run into dimension mismatch issues (since Observables are synchronously updated).","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"TODO add more tips here","category":"page"},{"location":"animation.html#Animating-a-plot-\"live\"-1","page":"Animation","title":"Animating a plot \"live\"","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"You can animate a plot in a for loop:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"for i = 1:length(r)\n    s[:markersize] = r[i]\n    # AbstractPlotting.force_update!() is no longer needed\n    sleep(1/24)\nend","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"Similarly, for plots based on functions:","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"scene = Scene()\nv = range(0, stop=4pi, length=50)\nf(v, t) = sin(v + t) # some function\ns = lines!(\n    scene,\n    lift(t -> f.(v, t), time),\n)[end];\n\nfor i = 1:length(v)\n    time[] = i\n    sleep(1/24)\nend","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"If you want to animate a plot while interacting with it, check out the async_latest function, and the Interaction section.","category":"page"},{"location":"animation.html#More-complex-examples-1","page":"Animation","title":"More complex examples","text":"","category":"section"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"@example_database(\"Animated surface and wireframe\")","category":"page"},{"location":"animation.html#","page":"Animation","title":"Animation","text":"You can see yet more complicated examples in the Example Gallery!","category":"page"},{"location":"index.html#Makie.jl-Documentation-1","page":"Home","title":"Makie.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Hi! Welcome to Makie, a high-performance, extendable, and multi-platform plotting package for Julia.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":" <iframe src=\"http://juliaplots.org/MakieReferenceImages/gallery/index.html\" height=\"1000\" width=\"100%\" frameborder=\"0\"></iframe>","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"For more examples, see the Example Gallery.","category":"page"},{"location":"index.html#Installation-and-tutorial-1","page":"Home","title":"Installation & tutorial","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"See the Tutorial.","category":"page"},{"location":"index.html#I'm-an-expert!-1","page":"Home","title":"I'm an expert!","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Head straight to the Plotting functions overview.","category":"page"},{"location":"index.html#The-Ecosystem:-1","page":"Home","title":"The Ecosystem:","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"What makes up the Makie Ecosystem? Makie.jl is the metapackage for a rich ecosystem, which consists of GLMakie.jl, CairoMakie.jl and WGLMakie.jl (the backends); AbstractPlotting.jl (the bulk of the package); and StatsMakie.jl (statistical plotting support, as in StatsPlots.jl).","category":"page"},{"location":"recipes.html#Plot-Recipes-1","page":"Plot Recipes","title":"Plot Recipes","text":"","category":"section"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"Recipes allow you to extend Makie with your own custom types and plotting commands.","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"There are two types of recipes. Type recipes define a simple mapping from a user defined type to an existing plot type. Full recipes can customize the theme and define a custom plotting function.","category":"page"},{"location":"recipes.html#Type-recipes-1","page":"Plot Recipes","title":"Type recipes","text":"","category":"section"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"Type recipes are really simple and just overload the argument conversion pipeline, converting from one type to another, plottable type.","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"warning: Warning\nconvert_arguments must always return a Tuple.","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"An example is:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"convert_arguments(x::Circle) = (decompose(Point2f, x),)","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"This can be done for all plot types or for a subset of plot types:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"# All plot types\nconvert_arguments(P::Type{<:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))\n# Only for scatter plots\nconvert_arguments(P::Type{<:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"Optionally you may define the default plot type so that plot(x::MyType) will use this:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"plottype(::MyType) = Surface","category":"page"},{"location":"recipes.html#Full-recipes-with-the-@recipe-macro-1","page":"Plot Recipes","title":"Full recipes with the @recipe macro","text":"","category":"section"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"A full recipe for MyPlot comes in two parts. First is the plot type name, arguments and theme definition which are defined using the @recipe macro. Second is a custom plot! for MyPlot, implemented in terms of the atomic plotting functions. We use an example to show how this works:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"# arguments (x, y, z) && theme are optional\n@recipe(MyPlot, x, y, z) do scene\n    Theme(\n        plot_color => :red\n    )\nend","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"This macro expands to several things. Firstly a type definition:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"const MyPlot{ArgTypes} = Combined{myplot, ArgTypes}","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"The type parameter of Combined contains the function instead of e.g. a symbol. This way the mapping from MyPlot to myplot is safer and simpler. (The downside is we always need a function myplot - TODO: is this a problem?) The following signatures are defined to make MyPlot nice to use:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"myplot(args...; kw_args...) = ...\nmyplot!(scene, args...; kw_args...) = ...\nmyplot(kw_args::Dict, args...) = ...\nmyplot!(scene, kw_args::Dict, args...) = ...\n#etc (not 100% settled what signatures there will be)","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"A specialization of argument_names is emitted if you have an argument list (x,y,z) provided to the recipe macro:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"`argument_names(::Type{<: MyPlot}) = (:x, :y, :z)`","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"This is optional but it will allow the use of plot_object[:x] to fetch the first argument from the call plot_object = myplot(rand(10), rand(10), rand(10)), for example.","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"Alternatively you can always fetch the ith argument using plot_object[i], and if you leave out the (x,y,z), the default version of argument_names will provide plot_object[:arg1] etc.","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"The theme given in the body of the @recipe invocation is inserted into a specialization of default_theme which inserts the theme into any scene that plots Myplot:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"function default_theme(scene, ::Myplot)\n    Theme(\n        plot_color => :red\n    )\nend","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"As the second part of defining MyPlot, you should implement the actual plotting of the MyPlot object by specializing plot!:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"function plot!(plot::MyPlot)\n    # normal plotting code, building on any previously defined recipes\n    # or atomic plotting operations, and adding to the combined `plot`:\n    lines!(plot, rand(10), color = plot[:plot_color])\n    plot!(plot, plot[:x], plot[:y])\n    plot\nend","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"It's possible to add specializations here, depending on the argument types supplied to myplot. For example, to specialize the behavior of myplot(a) when a is a 3D array of floating point numbers:","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"const MyVolume = MyPlot{Tuple{<:AbstractArray{<: AbstractFloat, 3}}}\nargument_names(::Type{<: MyVolume}) = (:volume,) # again, optional\nfunction plot!(plot::MyVolume)\n    # plot a volume with a colormap going from fully transparent to plot_color\n    volume!(plot, plot[:volume], colormap = :transparent => plot[:plot_color])\n    plot\nend","category":"page"},{"location":"recipes.html#","page":"Plot Recipes","title":"Plot Recipes","text":"@example_database(\"Type recipe for molecule simulation\")","category":"page"}]
}
